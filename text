#include "minirt.h"

int	array_len(char **array)
{
	int	i;

	if (!array)
		return (0);
	i = 0;
	while (array[i])
		i++;
	return (i);
}

void	free_array(char **array)
{
	int	i;

	i = 0;
	if (!array)
		return ;
	while (array[i] != NULL)
		free(array[i++]);
	free(array);
}
#include "minirt.h"

static t_vec3	box_entry_exit(t_vec3 h, t_vec3 ro, t_vec3 rd)
{
	const t_vec3	m = vec3(1.0f / (rd.x + (rd.x == 0.0f) * 1e-6f), 1.0f
			/ (rd.y + (rd.y == 0.0f) * 1e-6f), 1.0f / (rd.z + (rd.z == 0.0f)
				* 1e-6f));
	const t_vec3	n = mul3(m, ro);
	const t_vec3	k = mul3(vec3(fabsf(m.x), fabsf(m.y), fabsf(m.z)), h);
	const t_vec3	t1 = sub3(scale3(n, -1.0f), k);
	const t_vec3	t2 = add3(scale3(n, -1.0f), k);

	return (vec3(fmaxf(fmaxf(t1.x, t1.y), t1.z), fminf(fminf(t2.x, t2.y), t2.z),
			0.0f));
}

float	box_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	t_vec3	h;
	float	tn;
	float	tf;
	t_vec3	tt;

	h = scale3(o->size, 0.5f);
	tt = box_entry_exit(h, ro, rd);
	tn = tt.x;
	tf = tt.y;
	if (tn > tf || tf < 0.0f)
		return (1e9f);
	if (tn > 0.0f)
		return (tn);
	return (tf);
}

static t_vec3	box_face_normal(t_vec3 p, t_vec3 h)
{
	t_vec3	q;
	t_vec3	d;

	q = vec3(fabsf(p.x), fabsf(p.y), fabsf(p.z));
	d = sub3(q, h);
	if (d.x > d.y && d.x > d.z)
		return (vec3(copysignf(1.0f, p.x), 0.0f, 0.0f));
	if (d.y > d.z)
		return (vec3(0.0f, copysignf(1.0f, p.y), 0.0f));
	return (vec3(0.0f, 0.0f, copysignf(1.0f, p.z)));
}

static t_vec3	box_face_uv(t_object *o, t_shading *s, t_vec3 p, t_vec3 h)
{
	float	u;
	float	v;

	if (fabsf(s->normal.x) > 0.5f)
	{
		s->tangent = vec3(0.0f, 0.0f, 1.0f);
		u = (p.z + h.z) / o->size.z;
		v = (p.y + h.y) / o->size.y;
	}
	else if (fabsf(s->normal.y) > 0.5f)
	{
		s->tangent = vec3(1.0f, 0.0f, 0.0f);
		u = (p.x + h.x) / o->size.x;
		v = (p.z + h.z) / o->size.z;
	}
	else
	{
		s->tangent = vec3(1.0f, 0.0f, 0.0f);
		u = (p.x + h.x) / o->size.x;
		v = (p.y + h.y) / o->size.y;
	}
	return (vec3(clamp(u, 0.0f, 1.0f), clamp(v, 0.0f, 1.0f), 0.0f));
}

void	box_params(t_object *o, t_shading *s)
{
	t_vec3	p;
	t_vec3	h;

	p = s->point;
	h = scale3(o->size, 0.5f);
	s->normal = box_face_normal(p, h);
	s->texcoord = box_face_uv(o, s, p, h);
}
#include "minirt.h"

// Handle mouse movement of the camera, pitching around the x-axis when the
// mouse is moved up or down, and yawing around the y-axis when it's moved
// sideways. Returns true if the camera moved.

static bool	camera_mouse_movement(t_render *r)
{
	const float		fov = radians(r->scene->fov);
	const float		sensitivity = MOUSE_SENSITIVITY * sinf(fov * 0.5f);
	static int32_t	prev[2];
	int32_t			curr[2];
	int32_t			delta[2];

	mlx_get_mouse_pos(r->mlx, &curr[0], &curr[1]);
	delta[0] = curr[0] - prev[0];
	delta[1] = curr[1] - prev[1];
	prev[0] = curr[0];
	prev[1] = curr[1];
	if (mlx_is_mouse_down(r->mlx, MLX_MOUSE_BUTTON_LEFT)
		&& (delta[0] != 0 || delta[1] != 0))
	{
		r->camera_yaw += sensitivity * delta[0];
		r->camera_pitch += sensitivity * delta[1];
		r->camera_pitch = clamp(r->camera_pitch, radians(1), radians(179));
		r->scene->dir.x = sin(r->camera_pitch) * cos(r->camera_yaw);
		r->scene->dir.y = cos(r->camera_pitch);
		r->scene->dir.z = sin(r->camera_pitch) * sin(r->camera_yaw);
		return (true);
	}
	return (false);
}

// Handle keyboard movement of the camera, moving horizontally with the WASD
// keys, and vertically with the shift/space keys. Returns true if the camera
// moved.

static bool	camera_keyboard_movement(t_render *r)
{
	t_vec3	vec;
	t_vec3	move_x;
	t_vec3	move_z;
	t_keys	keys;

	move_x = norm3(vec3(r->camera_x.x, 0.0f, r->camera_x.z));
	move_z = norm3(vec3(r->camera_z.x, 0.0f, r->camera_z.z));
	keys.forward = mlx_is_key_down(r->mlx, KEY_FORWARD);
	keys.left = mlx_is_key_down(r->mlx, KEY_LEFT);
	keys.back = mlx_is_key_down(r->mlx, KEY_BACK);
	keys.right = mlx_is_key_down(r->mlx, KEY_RIGHT);
	keys.up = mlx_is_key_down(r->mlx, KEY_UP);
	keys.down = mlx_is_key_down(r->mlx, KEY_DOWN);
	vec = vec3(0.0f, keys.up - keys.down, 0.0f);
	vec = add3(vec, scale3(move_x, keys.right - keys.left));
	vec = add3(vec, scale3(move_z, keys.back - keys.forward));
	vec = scale3(vec, 3.0f * r->mlx->delta_time);
	r->scene->pos = add3(r->scene->pos, vec);
	return (len3(vec) > 0.0f);
}

// Update the basis vectors for the camera coordinate system, and and find the
// direction vectors pointing toward the four corners of the viewport.

static void	camera_update_viewport(t_render *r)
{
	const float	view_h = 0.5f * tan(radians(r->scene->fov) * 0.5f);
	const float	view_w = view_h * (float) r->image->width / r->image->height;
	t_vec3		vec[4];

	r->camera_z = scale3(r->scene->dir, -1.0f);
	r->camera_x = norm3(cross3(vec3(0, 1, 0), r->camera_z));
	r->camera_y = cross3(r->camera_z, r->camera_x);
	vec[0] = scale3(r->camera_x, -view_w);
	vec[1] = scale3(r->camera_x, +view_w);
	vec[2] = scale3(r->camera_y, +view_h);
	vec[3] = scale3(r->camera_y, -view_h);
	r->viewport[0] = sub3(add3(vec[0], vec[2]), r->camera_z);
	r->viewport[1] = sub3(add3(vec[1], vec[2]), r->camera_z);
	r->viewport[2] = sub3(add3(vec[0], vec[3]), r->camera_z);
	r->viewport[3] = sub3(add3(vec[1], vec[3]), r->camera_z);
}

// Update all camera parameters. Called before rendering a new frame.

void	camera_update(t_render *r)
{
	if (camera_mouse_movement(r))
		r->frame_samples = 0;
	camera_update_viewport(r);
	if (camera_keyboard_movement(r))
		r->frame_samples = 0;
	r->jitter = random_point_in_square(r->frame_samples++);
}
#include "minirt.h"

// Get the distance along a ray to a cylinder body.

static float	body_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	const float	a = (rd.x * rd.x + rd.z * rd.z);
	const float	b = (rd.x * ro.x + rd.z * ro.z) * 2.0f;
	const float	c = (ro.x * ro.x + ro.z * ro.z) - o->radius * o->radius;
	const float	t = solve_quadratic(a, b, c);

	if (fabsf(ro.y + t * rd.y) > o->height * 0.5f)
		return (1e9f);
	return (t);
}

// Get the distance along a ray to a cylinder end cap (a disk).

static float	disk_distance(t_object *o, t_vec3 ro, t_vec3 rd, float h)
{
	const float		t = (h - ro.y) / rd.y;
	const float		x = ro.x + t * rd.x;
	const float		z = ro.z + t * rd.z;

	if (t < 0.0f || x * x + z * z > o->radius * o->radius)
		return (1e9f);
	return (t);
}

// Get the distance along a ray to a full cylinder.

float	cylinder_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	const float	body = body_distance(o, ro, rd);
	const float	top = disk_distance(o, ro, rd, -0.5f * o->height);
	const float	bot = disk_distance(o, ro, rd, +0.5f * o->height);

	return (fminf(body, fminf(top, bot)));
}

void	cylinder_params(t_object *o, t_shading *s)
{
	const float		h = o->height * 0.5f - 1e-6f;
	const t_vec3	p = s->point;

	if (fabsf(p.y) < h)
	{
		s->normal = scale3(vec3(p.x, 0.0f, p.z), 1.0f / o->radius);
		s->tangent = norm3(cross3(s->normal, vec3(0, 1, 0)));
		s->texcoord.y = clamp(p.y, -h, h);
		s->texcoord.x = atan2f(p.x, p.z) / M_PI * 0.5f + 0.5f;
	}
	else
	{
		s->normal = vec3(0.0f, copysignf(1.0f, p.y), 0.0f);
		s->tangent = vec3(1.0f, 0.0f, 0.0f);
		s->texcoord = vec3(-s->point.x, s->point.z, 0.0f);
	}
}
#include "minirt.h"

/* Inline fatal_if implementation (previously mrt_assert) */
static void	cleanup_parsing(t_parse *ctx)
{
	get_next_line(-1);
	if (ctx->fd >= 0)
		close(ctx->fd);
	if (ctx->buff)
		free(ctx->buff);
	if (ctx->line)
		free_array(ctx->line);
	if (ctx->sc->objects)
		free(ctx->sc->objects);
}

void	fatal_if(t_parse *ctx, bool condition, char *format, ...)
{
	const int	errno_value = errno;
	va_list		args;

	if (!condition)
		return ;
	ft_fprintf(2, "Error\n");
	if (format != NULL || errno_value != 0)
	{
		if (errno_value != 0)
		{
			ft_putstr_fd(strerror(errno_value), STDERR_FILENO);
			ft_putstr_fd(": ", STDERR_FILENO);
			write(STDERR_FILENO, "\n", 1);
		}
		if (format)
		{
			va_start(args, format);
			printf_fd(2, format, &args);
			va_end(args);
		}
	}
	cleanup_parsing(ctx);
	exit(EXIT_FAILURE);
}

/* Dynamic array push-back for scene objects.
 * - Initial static capacity = 64
 * - Doubles on growth.
 * - Exits via fatal_if on allocation failure.
 * - Returns zeroed slot.
 */
t_object	*object_new(t_parse *map)
{
	static size_t	capacity = 64;
	t_object		*slot;
	t_object		*new_storage;

	if (map->sc->objects == NULL)
	{
		map->sc->objects = malloc(capacity * sizeof(t_object));
		fatal_if(map, map->sc->objects == NULL, "Allocation failure\n");
		memset(map->sc->objects, 0, capacity * sizeof(t_object));
	}
	else if (map->sc->object_count == capacity)
	{
		capacity *= 2;
		new_storage = malloc(capacity * sizeof(t_object));
		fatal_if(map, new_storage == NULL, "Allocation failure\n");
		memcpy(new_storage, map->sc->objects,
			map->sc->object_count * sizeof(t_object));
		free(map->sc->objects);
		memset(new_storage + map->sc->object_count, 0,
			(capacity - map->sc->object_count) * sizeof(t_object));
		map->sc->objects = new_storage;
	}
	slot = &map->sc->objects[map->sc->object_count++];
	memset(slot, 0, sizeof(*slot));
	return (slot);
}

static void	read_map_into_scene(t_parse *map)
{
	char	*nl;

	while (1)
	{
		map->buff = get_next_line(map->fd);
		if (!map->buff)
			break ;
		if (!ft_str_is_whitespace(map->buff))
		{
			nl = ft_strrchr(map->buff, '\n');
			if (nl != NULL)
				*nl = '\0';
			map->line = ft_split(map->buff, ' ');
			fatal_if(map, map->line == NULL, "Allocation fail during split\n");
			if (map->line[0][0] != '#')
				parse_type(map);
			free_array(map->line);
			map->line = NULL;
		}
		free(map->buff);
	}
}

void	validate_input_and_parse_map(int ac, char **av, t_parse *m)
{
	fatal_if(m, ac != 2, "usage: ./miniRT <path_to_the_file.rt>\n");
	fatal_if(m, ft_strcmp(ft_strrchr(av[1], '.'), ".rt"), "Not .rt file\n");
	m->fd = open(av[1], O_RDONLY);
	fatal_if(m, m->fd < 0, "Error\nCould not open file %s\n", av[1]);
	read_map_into_scene(m);
	get_next_line(-1);
	close(m->fd);
	fatal_if(m, m->sc->object_count <= 0, "Not enough objects provided\n");
}
#include "minirt.h"

// MLX loop hook. Runs every frame to render the next image.

static void	loop_hook(void *param)
{
	t_render *const	r = (t_render*) param;
	t_object *const	object = &r->scene->objects[3];
	t_quat			rotate;

	pthread_mutex_lock(&r->mutex);
	if (mlx_is_key_down(r->mlx, MLX_KEY_J))
	{
		rotate = quat_from_axis_angle(vec3(1.0f, 0.0f, 0.0f), 0.03f);
		object->rot = quat_multiply(rotate, object->rot);
		r->frame_samples = 0;
	}
	camera_update(r);
	show_stats_in_window_title(r);
	r->jobs_available += THREAD_COUNT;
	pthread_cond_broadcast(&r->available_cond);
	while (r->jobs_finished < r->jobs_available)
		pthread_cond_wait(&r->finished_cond, &r->mutex);
	pthread_mutex_unlock(&r->mutex);
}

// MLX key hook. Used to quit when the escape key is pressed.

static void	key_hook(mlx_key_data_t data, void *param)
{
	t_render *const	r = (t_render*) param;

	if (data.action != MLX_PRESS)
		return ;
	if (data.key == MLX_KEY_ESCAPE)
		mlx_close_window(r->mlx);
	if (data.key == MLX_KEY_F)
	{
		r->fancy = !r->fancy;
		r->frame_samples = 0;
	}
}

// MLX window resize hook. Resizes the image to match the new window dimensions.

static void	resize_hook(int32_t width, int32_t height, void *param)
{
	t_render *const	r = (t_render*) param;
	const size_t	min_size = width * height * sizeof(t_vec3);

	mlx_resize_image(r->image, width, height);
	if (min_size > r->frame_size)
	{
		r->frame_size = min_size;
		free(r->frame);
		r->frame = malloc(r->frame_size);
		if (r->frame == NULL)
			mlx_close_window(r->mlx);
	}
	r->frame_samples = 0;
}

// Renderer entry point. Sets up the MLX state and installs all event hooks.

void	render_scene(t_render *r)
{
	r->camera_yaw = atan2(r->scene->dir.z, r->scene->dir.x);
	r->camera_pitch = acos(r->scene->dir.y);
	r->mlx = mlx_init(1 * 480, 1 * 360, "miniRT", true);
	if (r->mlx != NULL)
	{
		r->image = mlx_new_image(r->mlx, r->mlx->width, r->mlx->height);
		if (r->image && mlx_image_to_window(r->mlx, r->image, 0, 0) != -1)
		{
			r->frame_size = r->mlx->width * r->mlx->height * sizeof(t_vec3);
			r->frame = malloc(r->frame_size);
			if (r->frame != NULL)
			{
				mlx_key_hook(r->mlx, key_hook, r);
				mlx_resize_hook(r->mlx, resize_hook, r);
				if (mlx_loop_hook(r->mlx, loop_hook, r) && threads_init(r))
					mlx_loop(r->mlx);
				threads_quit(r);
			}
			free(r->frame);
		}
		mlx_delete_image(r->mlx, r->image);
	}
	mlx_terminate(r->mlx);
}
#include "minirt.h"

void	init_structs(t_scene *scene, t_render *render, t_parse *map)
{
	ft_bzero(scene, sizeof(t_scene));
	ft_bzero(render, sizeof(t_render));
	ft_bzero(map, sizeof(t_parse));
	map->sc = scene;
	map->fd = -1;
	render->scene = scene;
	scene->objects = NULL;
}

int	main(int ac, char **av)
{
	t_scene		scene;
	t_render	render;
	t_parse		map;

	init_structs(&scene, &render, &map);
	validate_input_and_parse_map(ac, av, &map);
	render_scene(&render);
	free(scene.objects);
	return (0);
}
#include "minirt.h"

// Clamp a value to the range [lower, upper].

float	clamp(float value, float lower, float upper)
{
	return (fmax(lower, fmin(upper, value)));
}

// Clamp a value to the range [0, 1].

float	saturate(float value)
{
	return (clamp(value, 0.0f, 1.0f));
}

// Convert an angle from degrees to radians.

float	radians(float degrees)
{
	return (degrees * (M_PI / 180.0f));
}

// Get the fractional part of a floating point number. (Discard the digits
// before the decimal point.)

float	fract(float x)
{
	return (x - floorf(x));
}

// Solve the quadratic equation ax² + bx + c. Returns the lower of the two
// roots, or if the lower root is negative, returns the higher root. If no
// solution exists, returns a huge float value.

float	solve_quadratic(float a, float b, float c)
{
	const float	d = b * b - 4.0f * a * c;

	if (d < 0.0f)
		return (1e9f);
	return ((copysignf(sqrtf(d), b + sqrtf(d)) - b) / (2.0f * a));
}
#ifndef MINIRT_H
# define MINIRT_H

# include <errno.h>
# include <fcntl.h>
# include <math.h>
# include <pthread.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>

# include "../assets/MLX42/include/MLX42/MLX42.h"
# include "../assets/libft/libft.h"

// Mouse sensitivity.
# define MOUSE_SENSITIVITY 0.006

// Key bindings.
# define KEY_FORWARD	MLX_KEY_W			// Walk forward
# define KEY_LEFT		MLX_KEY_A			// Strafe left
# define KEY_BACK		MLX_KEY_S			// Walk backward
# define KEY_RIGHT		MLX_KEY_D			// Strafe right
# define KEY_UP			MLX_KEY_SPACE		// Float up
# define KEY_DOWN		MLX_KEY_LEFT_SHIFT	// Sink down

// Minimum roughness value. Roughness values of zero easily make lighting
// calculations blow up, so we impose an arbitrary limit on how shiny surfaces
// can be.
# define MIN_ROUGHNESS 0.01

// Default roughness and metallicness values. These are used for objects that
// don't set these values in the map file.
# define DEFAULT_ROUGH 0.1
# define DEFAULT_METALLIC 0.5

// How much bump mapping affects surface normals. Higher values produce a
// bumpier, less subtle effect.
# define BUMP_MAP_STRENGTH 0.05

// Maximum number of ray bounces used when reflecting rays off surfaces. Higher
// values make indirect light and mirror reflections more convincing, but come
// at a performance cost.
# define MAX_RAY_BOUNCES 3

// The number of rendering threads to use.
# define THREAD_COUNT 12

// Typedefs for enum/structure/union types.
typedef enum e_object_type	t_object_type;
typedef enum e_texture		t_texture;
typedef struct s_keys		t_keys;
typedef struct s_object		t_object;
typedef struct s_shading	t_shading;
typedef struct s_ray		t_ray;
typedef struct s_render		t_render;
typedef struct s_scene		t_scene;
typedef struct s_thread		t_thread;
typedef struct s_parse		t_parse;
typedef union u_quat		t_quat;
typedef union u_vec3		t_vec3;

// Typedefs for function types.
typedef float				(*t_distance_function)(t_object*, t_vec3, t_vec3);
typedef void				(*t_params_function)(t_object*, t_shading*);
typedef float				(*t_texture_function)(float, float);

// 3D coordinate vector type (also used for colors).
union	u_vec3
{
	struct // XYZ coordinate vector
	{
		float	x;
		float	y;
		float	z;
	};
	struct // RGB color vector
	{
		float	r;
		float	g;
		float	b;
	};
};

// Quaternion type (used for rotating/orienting objects).
union	u_quat
{
	struct
	{
		float	x;		// Imaginary
		float	y;		// Imaginary
		float	z;		// Imaginary
		float	w;		// Real
	};
	t_vec3		xyz;	// Imaginary parts as vector
};

// Enumeration for different scene object types.
enum	e_object_type
{
	OBJECT_PLANE,
	OBJECT_SPHERE,
	OBJECT_CYLINDER,
	OBJECT_PARA,
	OBJECT_BOX,
	OBJECT_LIGHT,
};

// Enumeration type for different procedural textures.
enum	e_texture
{
	TEXTURE_NONE,
	TEXTURE_CHECKED,
	TEXTURE_ZIGZAG,
	TEXTURE_POLKADOT,
	TEXTURE_MARBLE,
};

// Data describing one geometric object or light in the scene.
struct s_object
{
	t_object_type	type;		// Object type (one of OBJECT_xxx)
	t_vec3			pos;		// Object position in world coordinates
	t_quat			rot;		// Object rotation relative to world coordinates
	t_vec3			color;		// Base color (albedo)
	float			radius;		// Radius (sphere/cylinder/para/light)
	float			height;		// Height (cylinder/para)
	t_vec3			size;		// Full dimensions (box)
	t_texture		texture;	// Texture map (or TEXTURE_NONE )
	t_texture		bumpmap;	// bump map(if any)
	float			rough;		// Surface roughness
	float			metallic;	// Surface metalness
};

struct s_ray
{
	t_scene		*scene;	// Scene data (read only!)
	uint16_t	rng;	// Index used for random number generation
	t_vec3		ro;		// Ray origin
	t_vec3		rd;		// Ray direction
	int			bounce;	// Remaining ray bounces
	bool		fancy;	// Use "fancy" shading
};

// Data describing the objects in the scene.
struct s_scene
{
	t_object	*objects;		// Array of objects in the scene
	size_t		object_count;	// Length of the objects array
	t_vec3		pos;			// Camera position
	t_vec3		dir;			// Camera direction (normalized)
	float		fov;			// Camera field of view (in degrees)
	float		focus_depth;	// Camera focus depth
	float		aperture_size;	// Camera aperture size
	t_vec3		ambient;		// Ambient color (multiplied by ratio)
};

// Data for the current keyboard state.
struct s_keys
{
	int	forward;	// State of the key for walking forward
	int	back;		// State of the key for walking backward
	int	left;		// State of the key for strafing left
	int	right;		// State of the key for strafing right
	int	up;			// State of the key for floating up
	int	down;		// State of the key for sinking down
};

// Common renderer state.
struct s_render
{
	t_scene			*scene;					// The scene to render
	mlx_t			*mlx;					// MLX state
	mlx_image_t		*image;					// MLX image
	float			camera_yaw;				// Camera yaw angle (in radians)
	float			camera_pitch;			// Camera pitch angle (in radians)
	t_vec3			camera_x;				// Camera "right" vector
	t_vec3			camera_y;				// Camera "down" vector
	t_vec3			camera_z;				// Camera "forward" vector
	t_vec3			viewport[4];			// The four corners of the viewport
	t_vec3			*frame;					// Floating point frame buffer
	size_t			frame_size;				// Allocated size of the frame
	int				frame_samples;			// Number of accumulated samples
	t_vec3			jitter;					// Subpixel jitter
	pthread_t		threads[THREAD_COUNT];	// Array of rendering threads
	int				threads_started;		// How many threads were initialized
	bool			threads_stop;			// Set to stop the render threads
	size_t			jobs_available;			// Available render jobs
	size_t			jobs_finished;			// Finished render jobs
	pthread_cond_t	available_cond;			// Tells when jobs become available
	pthread_cond_t	finished_cond;			// Tells when all jobs are finished
	pthread_mutex_t	mutex;					// Protects common render state
	bool			fancy;					// Use "fancy" lighting
};

// Data for one render thread.
struct s_thread
{
	size_t	id;		// Index from 0 to THREAD_COUNT - 1
	size_t	job;	// Job index (always increasing)
	size_t	y_min;	// y-coordinate of top scanline of region
	size_t	y_max;	// y-coordinate of bottom scanline of region
};

// Structure data used during shading.
struct s_shading
{
	t_vec3	point;		// Surface point that's being shaded
	t_vec3	normal;		// Surface normal at shading point
	t_vec3	tangent;	// Tangent vector (points along texcoord.x)
	t_vec3	bitangent;	// Bitangent vector (points along texcoord.y)
	t_vec3	texcoord;	// Texture coordinate at the shading point
	t_vec3	f0;			// Surface reflection at zero incidence (for fresnel)
	t_vec3	albedo;		// Surface albedo at shaded point
	float	metallic;	// PBR metallic parameter
	float	rough;		// PBR roughness parameter
	t_vec3	view_dir;	// View direction (points toward camera)
	t_vec3	light;		// Light vector (from light to shading point)
	t_vec3	light_dir;	// Light direction (normalized light vector)
	t_vec3	halfway;	// Halfway vector (between normal and light direction)
	float	ndotv;		// (surface normal) · (view vector)
	float	ndotl;		// (surface normal) · (light vector)
	float	ndoth;		// (surface normal) · (halfway vector)
	float	hdotv;		// (halfway vector) · (view vector)
	t_vec3	diffuse;	// Diffuse contribution
	t_vec3	specular;	// Specular contribution
	t_vec3	ambient;	// Ambient contribution
};

// struct for parsing related things for easy exits
struct s_parse
{
	t_scene		*sc;
	char		*buff;
	char		**line;
	int			fd;
	t_object	*obj;
	t_vec3		normal;
	int			arrlen;
};

// camera.c
void		camera_update(t_render *r);

// cylinder.c
float		cylinder_distance(t_object *o, t_vec3 ro, t_vec3 rd);
void		cylinder_params(t_object *o, t_shading *s);

// box.c
float		box_distance(t_object *o, t_vec3 ro, t_vec3 rd);
void		box_params(t_object *o, t_shading *s);

// loop.c
void		render_scene(t_render *r);

// math.c
float		clamp(float value, float lower, float upper);
float		saturate(float value);
float		radians(float degrees);
float		fract(float x);
float		solve_quadratic(float a, float b, float c);

// object.c
float		object_distance(t_object *object, t_vec3 ro, t_vec3 rd);
void		object_params(t_object *o, t_shading *s);

// para.c
float		para_distance(t_object *o, t_vec3 ro, t_vec3 rd);
void		para_params(t_object *o, t_shading *s);

// plane.c
float		plane_distance(t_object *o, t_vec3 ro, t_vec3 rd);
void		plane_params(t_object *o, t_shading *s);

// quaternion.c
t_quat		quat_from_axis_angle(t_vec3 axis, float angle);
t_quat		quat_from_direction(t_vec3 direction);
t_quat		quat_multiply(t_quat a, t_quat b);
t_quat		quat_inverse(t_quat q);
t_vec3		quat_rotate_vec3(t_quat q, t_vec3 v);

// random.c
float		random_float(uint16_t rng);
t_vec3		random_point_in_square(uint16_t rng);
t_vec3		random_point_in_disk(uint16_t rng, float radius);
t_vec3		random_point_on_sphere(uint16_t rng, float radius);

// shading.c
void		apply_bumpmap(t_shading *s, t_texture bumpmap, t_vec3 tc);
t_vec3		shade_point(t_shading *s, t_ray *r, t_object *object);

// sphere.c
float		sphere_distance(t_object *o, t_vec3 ro, t_vec3 rd);
void		sphere_params(t_object *o, t_shading *s);

// texturing.c
float		get_texture(t_texture texture, float u, float v);

// threads.c
bool		threads_init(t_render *r);
void		threads_quit(t_render *r);

// title.c
void		show_stats_in_window_title(t_render *r);

// trace.c
float		scene_distance(t_scene *s, t_vec3 ro, t_vec3 rd, t_object **object);
t_vec3		get_viewport_ray(t_render *r, float x, float y, bool jitter);
t_vec3		trace_pixel(t_render *r, float x, float y);

// vec3_arithmetic.c
t_vec3		add3(t_vec3 a, t_vec3 b);
t_vec3		sub3(t_vec3 a, t_vec3 b);
t_vec3		mul3(t_vec3 a, t_vec3 b);
t_vec3		div3(t_vec3 a, t_vec3 b);
t_vec3		scale3(t_vec3 v, float s);

// vec3_geometric.c
float		dot3(t_vec3 a, t_vec3 b);
float		len3(t_vec3 v);
t_vec3		norm3(t_vec3 v);
t_vec3		cross3(t_vec3 a, t_vec3 b);
t_vec3		reflect3(t_vec3 i, t_vec3 n);

// vec3_utility.c
t_vec3		vec3(float x, float y, float z);
t_vec3		lerp3(t_vec3 a, t_vec3 b, float t);
t_vec3		tonemap3(t_vec3 color);
t_vec3		to_srgb3(t_vec3 color);
uint32_t	to_color3(t_vec3 color);

/* parsing of the map and validating the input input.c */
void		validate_input_and_parse_map(int ac, char **av, t_parse *map);
void		parse_sphere(t_parse *map);
void		parse_plane(t_parse *map);
void		parse_para(t_parse *map);
void		parse_cylinder(t_parse *map);
void		parse_box(t_parse *map);
void		parse_amb_light(t_parse *map);
void		parse_point_light(t_parse *map);
void		parse_type(t_parse *map);
void		parse_camera(t_parse *map);
t_object	*object_new(t_parse *map);
void		fatal_if(t_parse *map, bool condition, char *format, ...);
/* array	 utils */
int			array_len(char **array);
void		free_array(char **array);
/* vector parsing utils */
double		ft_atof(t_parse *m, const char *str);
bool		in_range3(t_vec3 v, float lower, float upper);
void		parse3(t_parse *m, const char *str, t_vec3 *out, float limits[2]);
/* debug.c */
void		debug_print_scene(t_scene *scene);

/* parse_utils.c */
float		parse_float(bool exists, t_parse *map, float std, int i);
t_texture	parse_texture(bool exists, t_parse *map, int i);
void		parse_optionals(t_parse *m, int texture_index);
#endif
#include "minirt.h"

float	object_distance(t_object *object, t_vec3 ro, t_vec3 rd)
{
	static const t_distance_function	functions[] = {
		plane_distance,
		sphere_distance,
		cylinder_distance,
		para_distance,
		box_distance,
		sphere_distance,
	};

	ro = quat_rotate_vec3(quat_inverse(object->rot), sub3(ro, object->pos));
	rd = quat_rotate_vec3(quat_inverse(object->rot), rd);
	return (functions[object->type](object, ro, rd));
}

void	object_params(t_object *o, t_shading *s)
{
	const t_vec3					p = s->point;
	static const t_params_function	functions[] = {
		plane_params,
		sphere_params,
		cylinder_params,
		para_params,
		box_params,
	};

	s->point = quat_rotate_vec3(quat_inverse(o->rot), sub3(p, o->pos));
	functions[o->type](o, s);
	s->normal = quat_rotate_vec3(o->rot, s->normal);
	s->tangent = quat_rotate_vec3(o->rot, s->tangent);
	s->point = p;
}
#include "minirt.h"

// Body intersection: ray vs para shell
static float	body_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	const float	k = (o->radius * o->radius) / o->height;
	const float	a = rd.x * rd.x + rd.z * rd.z;
	const float	b = 2.0f * (ro.x * rd.x + ro.z * rd.z) - k * rd.y;
	const float	c = (ro.x * ro.x + ro.z * ro.z) - k * (ro.y + 0.5f * o->height);
	const float	t = solve_quadratic(a, b, c);

	if (t < 0.0f || (ro.y + t * rd.y) < -0.5f * o->height || (ro.y + t
			* rd.y) > 0.5f * o->height)
		return (1e9f);
	return (t);
}

// Optional cap at top (y = +h/2), disk
static float	disk_distance(t_object *o, t_vec3 ro, t_vec3 rd, float h)
{
	const float	t = (h - ro.y) / rd.y;
	const float	x = ro.x + t * rd.x;
	const float	z = ro.z + t * rd.z;

	if (t < 0.0f || x * x + z * z > o->radius * o->radius)
		return (1e9f);
	return (t);
}

// Full intersection function
float	para_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	const float	body = body_distance(o, ro, rd);
	const float	top_cap = disk_distance(o, ro, rd, 0.5f * o->height);

	return (fminf(body, top_cap));
}

void	para_params(t_object *o, t_shading *s)
{
	const t_vec3	p = s->point;
	const float		k = (o->radius * o->radius) / o->height;

	if (fabsf(p.y - 0.5f * o->height) < 1e-4f)
		return (plane_params(o, s));
	s->normal = norm3(vec3(2.0f * p.x, -k, 2.0f * p.z));
	s->tangent = norm3(cross3(s->normal, vec3(0, 1, 0)));
	s->texcoord.y = clamp(p.y, -o->height * 0.5f, o->height * 0.5f);
	s->texcoord.x = atan2f(p.x, p.z) / M_PI * 0.5f + 0.5f;
}
#include "minirt.h"

void	parse_amb_light(t_parse *m)
{
	static bool	ambient_exists = false;
	double		ratio;

	fatal_if(m, array_len(m->line) != 3, "Invalid ambient light format\n");
	fatal_if(m, ambient_exists, "Ambient light already exists\n");
	ratio = ft_atof(m, m->line[1]);
	parse3(m, m->line[2], &m->sc->ambient, (float []){0, 255});
	fatal_if(m, ratio < 0.0f || ratio > 1.0f,
		"Ambient light ratio must be between 0.0 and 1.0\n");
	m->sc->ambient = scale3(m->sc->ambient, ratio / 255.0);
	ambient_exists = true;
}

void	parse_point_light(t_parse *m)
{
	double	brightness;

	m->arrlen = array_len(m->line);
	fatal_if(m, (m->arrlen != 4 && m->arrlen != 5),
		"Invalid point light format\n");
	brightness = ft_atof(m, m->line[2]);
	m->obj->type = OBJECT_LIGHT;
	if (m->arrlen == 5)
	{
		m->obj->radius = ft_atof(m, m->line[4]);
		fatal_if(m, fabs(m->obj->radius) == HUGE_VAL,
			"Light radius cant be infinite\n");
	}
	fatal_if(m, m->obj->radius < 0.0f, "Light radius must be positive\n");
	parse3(m, m->line[1], &m->obj->pos, (float []){0, 0});
	parse3(m, m->line[3], &m->obj->color, (float []){0, 255});
	fatal_if(m, brightness < 0.0f, "Light brightness must be positive\n");
	m->obj->color = scale3(m->obj->color, brightness / 255.0);
	m->obj->rot = quat_from_axis_angle(vec3(0.0f, -1.0f, 0.0f), 0.0f);
}

// Then in read_map_into_scene, when errors occur:
/*
 * the command is going through array of strings that was passed to it
 * it will take the positions, split them, check if the length is 3,
	error if it is not
 * convert it to floats, check if it is within the limits
 * error if it is not
 * do the same with fov but without spliting
 *
 */
void	parse_camera(t_parse *m)
{
	static bool	camera_exist = false;

	m->arrlen = array_len(m->line);
	fatal_if(m, m->arrlen < 4 || m->arrlen > 6, "Invalid camera format\n");
	fatal_if(m, camera_exist, "Camera already exist\n");
	m->sc->focus_depth = parse_float(m->arrlen > 4, m, 5.0f, 4);
	m->sc->aperture_size = parse_float(m->arrlen > 5, m, 0.0f, 5);
	fatal_if(m, fabs(m->sc->focus_depth) == HUGE_VAL
		|| fabs(m->sc->aperture_size) == HUGE_VAL,
		"Camera focus depth or aperture cannot be infinite\n");
	m->sc->fov = ft_atof(m, m->line[3]);
	parse3(m, m->line[1], &m->sc->pos, (float []){0, 0});
	parse3(m, m->line[2], &m->sc->dir, (float []){-1, 1});
	camera_exist = true;
	// fatal_if(m, fabsf(len3(m->sc->dir) - 1.0f) >= 0.001f,
	// 	"Camera direction components must be between -1 and 1\n");
	fatal_if(m, m->sc->fov < 0.0f || m->sc->fov > 180.0f,
		"Camera FOV must be between 0 and 180 degrees\n");
	fatal_if(m, m->sc->focus_depth < 0.0f,
		"Camera focus depth must be non-negative\n");
	fatal_if(m, m->sc->aperture_size < 0.0f,
		"Camera aperture size must be non-negative\n");
}
#include "minirt.h"

t_texture	parse_texture(bool exists, t_parse *map, int i)
{
	if (!exists || map->line[i] == NULL || ft_strcmp(map->line[i], "_") == 0)
		return (TEXTURE_NONE);
	if (ft_strcmp(map->line[i], "checked") == 0)
		return (TEXTURE_CHECKED);
	if (ft_strcmp(map->line[i], "zigzag") == 0)
		return (TEXTURE_ZIGZAG);
	if (ft_strcmp(map->line[i], "polkadot") == 0)
		return (TEXTURE_POLKADOT);
	if (ft_strcmp(map->line[i], "marble") == 0)
		return (TEXTURE_MARBLE);
	fatal_if(map,
		true,
		"Unknown texture '%s' (expected checked | zigzag | polkadot | marble)\n",
		map->line[i]);
	return (TEXTURE_NONE);
}

float	parse_float(bool exists, t_parse *map, float std, int i)
{
	if (!exists || map->line[i] == NULL || ft_strcmp(map->line[i], "_") == 0)
		return (std);
	return (ft_atof(map, map->line[i]));
}

void	parse_optionals(t_parse *m, int i)
{
	m->obj->rough = parse_float(m->arrlen > i, m, DEFAULT_ROUGH, i);
	fatal_if(m, m->obj->rough < 0.0f || m->obj->rough > 1.0f,
		"Rough must be in [0,1]\n");
	m->obj->metallic = parse_float(m->arrlen > i + 1, m,
			DEFAULT_METALLIC, i + 1);
	fatal_if(m, m->obj->metallic < 0.0f || m->obj->metallic > 1.0f,
		"Metallic must be in [0,1]\n");
	m->obj->texture = parse_texture(m->arrlen > i + 2, m, i + 2);
	m->obj->bumpmap = parse_texture(m->arrlen > i + 3, m, i + 3);
}
#include "minirt.h"

void	parse_sphere(t_parse *m)
{
	m->arrlen = array_len(m->line);
	fatal_if(m, m->arrlen < 4 || m->arrlen > 8, "Invalid sphere format\n");
	m->obj->type = OBJECT_SPHERE;
	parse_optionals(m, 4);
	parse3(m, m->line[1], &m->obj->pos, (float []){0, 0});
	parse3(m, m->line[3], &m->obj->color, (float []){0, 255});
	m->obj->radius = ft_atof(m, m->line[2]) * 0.5;
	fatal_if(m, fabs(m->obj->radius) == HUGE_VAL,
		"Sphere radius cannot be infinite\n");
	m->obj->color = scale3(m->obj->color, 1.0 / 255.0);
	m->obj->rot = quat_from_axis_angle(vec3(0.0f, -1.0f, 0.0f), 0.0f);
	fatal_if(m, m->obj->radius <= 0.0f, "Sphere radius must be positive\n");
}

void	parse_plane(t_parse *m)
{
	m->arrlen = array_len(m->line);
	fatal_if(m, m->arrlen < 4 || m->arrlen > 8, "Invalid plane format\n");
	m->obj->type = OBJECT_PLANE;
	parse_optionals(m, 4);
	parse3(m, m->line[1], &m->obj->pos, (float []){0, 0});
	parse3(m, m->line[2], &m->normal, (float []){-1, 1});
	parse3(m, m->line[3], &m->obj->color, (float []){0, 255});
	m->obj->color = scale3(m->obj->color, 1.0 / 255.0);
	fatal_if(m, fabsf(len3(m->normal) - 1.0f) >= 0.001f,
		"Plane normal must be a unit vector\n");
	m->obj->rot = quat_from_direction(m->normal);
}

void	parse_para(t_parse *m)
{
	m->arrlen = array_len(m->line);
	fatal_if(m, m->arrlen < 6 || m->arrlen > 10, "Invalid para format\n");
	m->obj->type = OBJECT_PARA;
	parse_optionals(m, 6);
	parse3(m, m->line[1], &m->obj->pos, (float []){0, 0});
	parse3(m, m->line[2], &m->normal, (float []){-1, 1});
	parse3(m, m->line[5], &m->obj->color, (float []){0, 255});
	m->obj->radius = ft_atof(m, m->line[3]) * 0.5;
	m->obj->height = ft_atof(m, m->line[4]);
	fatal_if(m, fabs(m->obj->radius) == HUGE_VAL
		|| fabs(m->obj->height) == HUGE_VAL,
		"Object radius and height cannot be infinite\n");
	m->obj->color = scale3(m->obj->color, 1.0 / 255.0);
	fatal_if(m, fabsf(len3(m->normal) - 1.0f) >= 0.001f,
		"Paraboloid axis must be a unit vector\n");
	fatal_if(m, m->obj->radius <= 0.0f || m->obj->height <= 0.0f,
		"Para radius and height must be positive\n");
	m->obj->rot = quat_from_direction(m->normal);
}

void	parse_cylinder(t_parse *m)
{
	m->arrlen = array_len(m->line);
	fatal_if(m, m->arrlen < 6 || m->arrlen > 10, "Invalid Cy format\n");
	m->obj->type = OBJECT_CYLINDER;
	parse_optionals(m, 6);
	parse3(m, m->line[1], &m->obj->pos, (float []){0, 0});
	parse3(m, m->line[2], &m->normal, (float []){-1, 1});
	parse3(m, m->line[5], &m->obj->color, (float []){0, 255});
	m->obj->radius = ft_atof(m, m->line[3]) * 0.5;
	m->obj->height = ft_atof(m, m->line[4]);
	fatal_if(m, fabs(m->obj->radius) == HUGE_VAL
		|| fabs(m->obj->height) == HUGE_VAL,
		"Object radius and height cannot be infinite\n");
	m->obj->color = scale3(m->obj->color, 1.0 / 255.0);
	fatal_if(m, fabsf(len3(m->normal) - 1.0f) >= 0.001f,
		"Cylinder axis must be a unit vector\n");
	fatal_if(m, m->obj->radius <= 0.0f || m->obj->height <= 0.0f,
		"Cylinder radius and height must be positive\n");
	m->obj->rot = quat_from_direction(m->normal);
}

void	parse_box(t_parse *m)
{
	m->arrlen = array_len(m->line);
	fatal_if(m, m->arrlen < 5 || m->arrlen > 9, "Invalid box format\n");
	m->obj->type = OBJECT_BOX;
	parse_optionals(m, 5);
	parse3(m, m->line[1], &m->obj->pos, (float []){0, 0});
	parse3(m, m->line[2], &m->normal, (float []){-1, 1});
	parse3(m, m->line[3], &m->obj->size, (float []){0, 0});
	parse3(m, m->line[4], &m->obj->color, (float []){0, 255});
	m->obj->color = scale3(m->obj->color, 1.0 / 255.0);
	fatal_if(m, fabsf(len3(m->normal) - 1.0f) >= 0.001f,
		"Box axis must be a unit vector\n");
	fatal_if(m, m->obj->size.x <= 0.0f || m->obj->size.y <= 0.0f
		|| m->obj->size.z <= 0.0f, "Box dimensions must be positive\n");
	m->obj->rot = quat_from_direction(m->normal);
}

void	parse_type(t_parse *m)
{
	const char			*id = m->line[0];
	static const char	*ids[] = {"sp", "pl", "cy", "pa", "bx", "L", "A", "C",
		NULL};
	static const char	alloc[] = {1, 1, 1, 1, 1, 1, 0, 0};
	int					i;
	static void (*const	f[])(t_parse *) = {
		parse_sphere, parse_plane, parse_cylinder,
		parse_para, parse_box, parse_point_light,
		parse_amb_light, parse_camera};

	i = 0;
	while (ids[i] && ft_strcmp(id, ids[i]))
		i++;
	if (!ids[i])
		fatal_if(m, true, "Not a valid type: %s\n", id);
	if (alloc[i])
		m->obj = object_new(m);
	else
		m->obj = NULL;
	f[i](m);
}
#include "minirt.h"

float	plane_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	(void) o;
	return (-ro.y / rd.y);
}

void	plane_params(t_object *o, t_shading *s)
{
	(void) o;
	s->normal = vec3(0.0f, 1.0f, 0.0f);
	s->tangent = vec3(1.0f, 0.0f, 0.0f);
	s->texcoord = vec3(-s->point.x, s->point.z, 0.0f);
}
#include "minirt.h"

// Create a quaternion from an axis and and an angle (in radians).

t_quat	quat_from_axis_angle(t_vec3 axis, float angle)
{
	const float	s = sinf(angle * 0.5f);
	const float	c = cosf(angle * 0.5f);

	return ((t_quat){{axis.x * s, axis.y * s, axis.z * s, c}});
}

// Create an orientation quaternion from a (normalized) direction vector.

t_quat	quat_from_direction(t_vec3 d)
{
	t_vec3	r;
	t_quat	q;

	if (fabsf(d.y + 1.0f) < 1e-6f)
		return ((t_quat){{1.0f, 0.0f, 0.0f, 0.0f}});
	if (fabsf(d.y - 1.0f) < 1e-6f)
		return ((t_quat){{0.0f, 0.0f, 0.0f, 1.0f}});
	r = norm3(vec3(d.x, d.y + 1.0f, d.z));
	q.xyz = cross3(r, d);
	q.w = dot3(r, d);
	return (q);
}

// Multiply two quaternions. This composes the rotations represented by the two
// quaternions.

t_quat	quat_multiply(t_quat a, t_quat b)
{
	const t_vec3	ab = scale3(a.xyz, b.w);
	const t_vec3	ba = scale3(b.xyz, a.w);
	const t_vec3	imag = add3(cross3(a.xyz, b.xyz), add3(ab, ba));
	const float		real = a.w * b.w - dot3(a.xyz, b.xyz);

	return ((t_quat){{imag.x, imag.y, imag.z, real}});
}

// Invert a quaternion. Conceptually, this reverses the rotation that the
// quaternion represents.

t_quat	quat_inverse(t_quat q)
{
	return ((t_quat){{-q.x, -q.y, -q.z, q.w}});
}

// Apply the rotation represented by the quaternion `q` to the 3D vector `v`.

t_vec3	quat_rotate_vec3(t_quat q, t_vec3 v)
{
	const t_vec3	a = add3(cross3(q.xyz, v), scale3(v, q.w));

	return (add3(v, scale3(cross3(q.xyz, a), 2.0f)));
}
#include "minirt.h"

// Generate a random float between 0 and 1.

float	random_float(uint16_t rng)
{
	return (fract(rng * (1.0f / 1.6180339887498948482f)));
}

// Generate a random point in the unit square [0, 1]². Uses a low-discrepancy
// sequence to generate the coordinates of the point. The constants used to
// randomize the x and y coordinates are equal to p¯¹ and  p¯², where p is the
// "plastic ratio." The plastic ratio is the unique real solution to the
// equation x³ = x + 1, a number with properties that are useful for generating
// numbers that look "random," but don't cluster together like truly random
// numbers do.

t_vec3	random_point_in_square(uint16_t rng)
{
	const float	x = fract(0.7548776662466927 * rng);
	const float	y = fract(0.5698402909980532 * rng);

	return (vec3(x, y, 0.0f));
}

// Generate a random point in a disk centered at the origin with the given
// radius.

t_vec3	random_point_in_disk(uint16_t rng, float radius)
{
	const t_vec3	p = random_point_in_square(rng);
	const float		x = sqrtf(p.x) * cosf(p.y * (2.0f * M_PI)) * radius;
	const float		y = sqrtf(p.x) * sinf(p.y * (2.0f * M_PI)) * radius;

	return (vec3(x, y, 0.0f));
}

// Generate a random point on a sphere centered at the origin with the given
// radius.

t_vec3	random_point_on_sphere(uint16_t rng, float radius)
{
	const t_vec3	p = random_point_in_square(rng);
	const float		x = sinf(p.x * M_PI) * cosf(p.y * (2.0f * M_PI));
	const float		y = sinf(p.x * M_PI) * sinf(p.y * (2.0f * M_PI));
	const float		z = cosf(p.x * M_PI);

	return (scale3(vec3(x, y, z), radius));
}
#include "minirt.h"

// Calculate the geometry (G) and normal distribution (D) factors of the
// Cook-Torrance BRDF.

static float	brdf_geo_dist(t_shading *s)
{
	const float	rough2 = s->rough * s->rough;
	const float	denom = ((s->ndoth * s->ndoth) * (rough2 - 1.0f) + 1.0f);
	const float	ggx1 = s->ndotv / (s->ndotv * (1.0f - s->rough) + s->rough);
	const float	ggx2 = s->ndotl / (s->ndotl * (1.0f - s->rough) + s->rough);
	const float	dist = rough2 / (M_PI * denom * denom);

	return (ggx1 * ggx2 * dist);
}

// Calculate the fresnel factor (F) of the Cook-Torrance BRDF.

static t_vec3	brdf_fresnel(t_shading *s)
{
	const float		factor = powf(1.0f - s->hdotv, 5.0f);
	const t_vec3	one = vec3(1.0f, 1.0f, 1.0f);

	return (add3(s->f0, scale3(add3(one, s->f0), factor)));
}

// Check if a light is visible from a shading point (located at `ro`). This is
// done by tracing a ray toward the light, stopping as soon as an occluding
// object is hit.

static bool	light_visible(t_ray *r, t_object *light, t_vec3 ro)
{
	const t_vec3	rand = random_point_on_sphere(r->rng, light->radius);
	const t_vec3	light_pos = add3(light->pos, rand);
	const t_vec3	rd = sub3(light_pos, ro);
	float			t;
	size_t			i;

	i = -1;
	while (++i < r->scene->object_count)
	{
		if (r->scene->objects[i].type == OBJECT_LIGHT)
			continue ;
		t = object_distance(&r->scene->objects[i], ro, rd);
		if (t >= 0.0f && t < 1.0f - 1e-3f)
			return (false);
	}
	return (true);
}

static t_vec3	one_light(t_ray *r, t_object *light, t_shading *s)
{
	t_vec3	specular;
	t_vec3	diffuse;
	t_vec3	radiance;

	s->view_dir = scale3(r->rd, -1.0f);
	s->light = sub3(light->pos, s->point);
	s->light_dir = norm3(s->light);
	s->halfway = norm3(add3(s->view_dir, s->light_dir));
	s->ndotv = saturate(dot3(s->normal, s->view_dir));
	s->ndotl = saturate(dot3(s->normal, s->light_dir));
	s->ndoth = saturate(dot3(s->normal, s->halfway));
	s->hdotv = saturate(dot3(s->halfway, s->view_dir));
	specular = brdf_fresnel(s);
	diffuse = sub3(vec3(1.0f, 1.0f, 1.0f), specular);
	diffuse = scale3(diffuse, (1.0f - s->metallic) / M_PI);
	diffuse = mul3(diffuse, s->albedo);
	specular = scale3(specular, brdf_geo_dist(s));
	specular = scale3(specular, 1.0f / (4.0f * s->ndotv * s->ndotl + 1e-4f));
	radiance = scale3(light->color, 2.0f);
	return (scale3(mul3(add3(diffuse, specular), radiance), s->ndotl));
}

void	apply_bumpmap(t_shading *s, t_texture bumpmap, t_vec3 tc)
{
	const float		delta = 1e-5f;
	const float		h = get_texture(bumpmap, tc.x, tc.y);
	const float		du = (get_texture(bumpmap, tc.x + delta, tc.y) - h) / delta;
	const float		dv = (get_texture(bumpmap, tc.x, tc.y + delta) - h) / delta;
	const t_vec3	m = norm3(vec3(du, dv, 1.0f / BUMP_MAP_STRENGTH));

	s->bitangent = cross3(s->normal, s->tangent);
	s->normal.x = dot3(m, vec3(s->tangent.x, s->bitangent.x, s->normal.x));
	s->normal.y = dot3(m, vec3(s->tangent.y, s->bitangent.y, s->normal.y));
	s->normal.z = dot3(m, vec3(s->tangent.z, s->bitangent.z, s->normal.z));
	s->normal = norm3(s->normal);
}

t_vec3	shade_point(t_shading *s, t_ray *r, t_object *object)
{
	t_vec3		color;
	t_object	*light;
	size_t		i;

	s->albedo.r = get_texture(object->texture, s->texcoord.x, s->texcoord.y);
	s->albedo = scale3(object->color, s->albedo.r);
	s->metallic = object->metallic;
	s->rough = fmaxf(MIN_ROUGHNESS, object->rough);
	s->f0 = lerp3(vec3(0.04f, 0.04f, 0.04f), s->albedo, s->metallic);
	s->normal = scale3(s->normal, copysignf(1.0f, -dot3(r->rd, s->normal)));
	color = mul3(s->ambient, s->albedo);
	i = -1;
	while (++i < r->scene->object_count)
	{
		light = &r->scene->objects[i];
		if (light->type == OBJECT_LIGHT && light_visible(r, light, s->point))
			color = add3(color, one_light(r, light, s));
	}
	return (color);
}
#include "minirt.h"

float	sphere_distance(t_object *s, t_vec3 ro, t_vec3 rd)
{
	const float		a = dot3(rd, rd);
	const float		b = dot3(rd, ro) * 2.0f;
	const float		c = dot3(ro, ro) - s->radius * s->radius;

	return (solve_quadratic(a, b, c));
}

void	sphere_params(t_object *o, t_shading *s)
{
	const t_vec3	p = s->point;

	s->normal = scale3(p, 1.0f / o->radius);
	s->tangent = norm3(cross3(s->normal, vec3(0.0f, 1.0f, 0.0f)));
	s->texcoord.x = fmaxf(0.0f, atan2f(p.x, p.z) / M_PI * 0.5f + 0.5f);
	s->texcoord.y = fmaxf(0.0f, asinf(p.y / o->radius) / M_PI + 0.5f);
}
#include "minirt.h"

static float	cloudy(t_vec3 x, float ampl, float freq)
{
	float	sum = 0.0f;
	t_vec3	n = vec3(1.0, 0.0, 0.0f);
	const float t = radians(180.0) * (3.0 - sqrt(5.0));

	for (int i = 0; i < 30; i++) {
		float p = freq * dot3(x, n);
		float y = fract(p);
		float v = 4.0f * (fabsf(y) * y - y);
		v = 1.0f - 2.0f * fabsf(v);
		sum += ampl * v;
		freq *= 1.25;
		ampl *= 0.9;
		n = vec3(cosf(t) * n.x - sinf(t) * n.y, sin(t) * n.x + cosf(t) * n.y, 0.0f);
	}
	return (saturate(sum * 0.1f + 1.5f) * 0.9f + 0.1f);
}

static float	texture_none(float u, float v)
{
	(void) u, (void) v;
	return (1.0f);
}

static float	texture_checked(float u, float v)
{
	u = floorf(u * 10.0f);
	v = floorf(v * 10.0f);
	return (fract((u + v) * 0.5f));
}

static float	texture_zigzag(float u, float v)
{
	const float	a = fabsf(fract(u * 3.0f + 0) * 2.0f - 1.0f);
	const float	b = fabsf(fract(v * 6.0f + a) * 2.0f - 1.0f);

	return (b * b * (3.0 - 2.0 * b));
}

static float	texture_polkadot(float u, float v)
{
#if 1
	const float	r = 0.5f;
	const float	x = fract(u * 2.0f) - 0.5f;
	const float	y = fract(v * 2.0f) - 0.5f;
	const float	b = 1.0f - saturate(sqrtf(x * x + y * y) / r);

	return (b * b * (3.0 - 2.0 * b));
#else
	const float	a = fabsf(fract(u * 3.0f + 0) * 2.0f - 1.0f);
	float	b = fabsf(fract(v * 6.0f + a) * 2.0f - 1.0f);

	b *= b;
	return (b * b * (3.0 - 2.0 * b));
#endif
}

static float	texture_marble(float u, float v)
{
	return (cloudy(vec3(u, v, 0.0f), 4.0f, 0.5f));
}

float	get_texture(t_texture texture, float u, float v)
{
	static const t_texture_function	functions[] = {
		texture_none,
		texture_checked,
		texture_zigzag,
		texture_polkadot,
		texture_marble,
	};

	return (functions[texture](u, v));
}
#include "minirt.h"

// Dithering function for masking color banding artifacts. The specific method
// is called Interleaved Gradient Noise; there are some good articles on it on
// the web.

static t_vec3	dither(float x, float y)
{
	x *= 0.06711056f;
	y *= 0.00583715f;
	x = fract(52.9829189f * fract(x + y)) / 255.0f;
	return (vec3(x, x, x));
}

// Render one thread's region of the frame. The region extends from y_min to
// y_max. During this function, it's important that the thread only reads from
// common render and scene data, to avoid data races. The only memory the thread
// should write to is the color/pixel data of its own region of the frame.

static void	threads_render(t_render *r, uint32_t y_min, uint32_t y_max)
{
	uint32_t		x;
	uint32_t		y;
	t_vec3			color;
	size_t			index;
	const size_t	pitch = sizeof(t_vec3) * r->image->width * (y_max - y_min);

	if (r->frame_samples == 1)
		memset(r->frame + y_min * r->image->width, 0, pitch);
	y = y_min - 1;
	while (++y < y_max)
	{
		x = -1;
		while (++x < r->image->width)
		{
			index = x + y * r->image->width;
			color = trace_pixel(r, x, y);
			color = tonemap3(color);
			r->frame[index] = add3(r->frame[index], color);
			color = scale3(r->frame[index], 1.0f / r->frame_samples);
			color = to_srgb3(color);
			color = add3(color, dither(x, y));
			mlx_put_pixel(r->image, x, y, to_color3(color));
		}
	}
}

// Render thread entry point. The frame is divided between threads into regions
// of equal size. When the MLX loop hook is called, the main thread increments
// the jobs_available counter to indicate that there is rendering work to be
// done. The render threads wait for work to become available, using a condition
// variable to avoid busy waiting. After rendering its region of the frame, each
// render thread increments the jobs_finished counter to indicate completion.
// When all jobs for one frame have finished, the main thread is signaled, after
// which it returns from the MLX loop hook, and the cycle repeats.

static void	*threads_main(void *arg)
{
	static _Atomic size_t	thread_id_counter;
	t_render *const			r = (t_render*) arg;
	t_thread				thread;

	thread.id = thread_id_counter++;
	thread.job = thread.id;
	while (true)
	{
		pthread_mutex_lock(&r->mutex);
		while (thread.job >= r->jobs_available && !r->threads_stop)
			pthread_cond_wait(&r->available_cond, &r->mutex);
		if (r->threads_stop)
			break ;
		pthread_mutex_unlock(&r->mutex);
		thread.y_min = r->image->height * (thread.id + 0) / THREAD_COUNT;
		thread.y_max = r->image->height * (thread.id + 1) / THREAD_COUNT;
		threads_render(r, thread.y_min, thread.y_max);
		pthread_mutex_lock(&r->mutex);
		if (++r->jobs_finished == r->jobs_available)
			pthread_cond_signal(&r->finished_cond);
		pthread_mutex_unlock(&r->mutex);
		thread.job += THREAD_COUNT;
	}
	pthread_mutex_unlock(&r->mutex);
	return (NULL);
}

// Create synchronization objects and start the render threads. Returns true on
// success, or false if an object couldn't be created. The threads_started
// counter keeps track of how many threads were actually started.

bool	threads_init(t_render *r)
{
	if (pthread_mutex_init(&r->mutex, NULL) != 0)
		return (false);
	if (pthread_cond_init(&r->available_cond, NULL) != 0
		|| pthread_cond_init(&r->finished_cond, NULL) != 0)
		return (false);
	while (r->threads_started < THREAD_COUNT)
	{
		if (pthread_create(&r->threads[r->threads_started], 0, threads_main, r))
			break ;
		r->threads_started++;
	}
	return (r->threads_started == THREAD_COUNT);
}

// Signal the render threads to stop, wait for all of them to finish, then
// destroy all synchronization objects.

void	threads_quit(t_render *r)
{
	pthread_mutex_lock(&r->mutex);
	r->threads_stop = true;
	pthread_cond_broadcast(&r->available_cond);
	pthread_mutex_unlock(&r->mutex);
	while (r->threads_started-- > 0)
		pthread_join(r->threads[r->threads_started], NULL);
	pthread_mutex_destroy(&r->mutex);
	pthread_cond_destroy(&r->available_cond);
	pthread_cond_destroy(&r->finished_cond);
}
#include "minirt.h"

// Add a string to the title buffer. Returns a pointer to the position in the
// buffer where the next character could be written.

static char	*add_string(char *buffer, char *string)
{
	while (*string != '\0')
		*buffer++ = *string++;
	return (buffer);
}

// Add an integer value to the title buffer. Returns a pointer to the position
// in the buffer where the next character could be written. Does not handle
// overflow if the value equals INT_MIN.

static char	*add_int(char *buffer, int value)
{
	if (value < 0)
	{
		*buffer++ = '-';
		return (add_int(buffer, -value));
	}
	if (value >= 10)
		buffer = add_int(buffer, value / 10);
	*buffer++ = '0' + value % 10;
	return (buffer);
}

// Build a string of useful stats and set it as the window title.

static void	update_window_title(t_render *r)
{
	char	title[256];
	char	*buffer;

	ft_bzero(title, sizeof(title));
	buffer = title;
	buffer = add_string(buffer, "miniRT — objects: ");
	buffer = add_int(buffer, r->scene->object_count);
	buffer = add_string(buffer, " | dt: ");
	buffer = add_int(buffer, r->mlx->delta_time * 1000.0);
	buffer = add_string(buffer, " ms");
	buffer = add_string(buffer, " | fps: ");
	buffer = add_int(buffer, 1.0 / r->mlx->delta_time);
	buffer = add_string(buffer, " | size: ");
	buffer = add_int(buffer, r->image->width);
	buffer = add_string(buffer, " x ");
	buffer = add_int(buffer, r->image->height);
	buffer = add_string(buffer, " | samples: ");
	buffer = add_int(buffer, r->frame_samples);
	mlx_set_window_title(r->mlx, title);
}

// Update the window title with useful stats, also rate-limiting title updates
// so that it's easier to read.

void	show_stats_in_window_title(t_render *r)
{
	static double	update_timer;
	const double	update_rate = 0.1;

	update_timer += r->mlx->delta_time;
	if (update_timer < update_rate)
		return ;
	update_timer = fmod(update_timer, update_rate);
	update_window_title(r);
}
#include "minirt.h"

float	scene_distance(t_scene *s, t_vec3 ro, t_vec3 rd, t_object **object)
{
	float	t_min;
	float	t;
	size_t	i;

	i = -1;
	if (object != NULL)
		*object = NULL;
	t_min = 1e9f;
	while (++i < s->object_count)
	{
		t = object_distance(&s->objects[i], ro, rd);
		if (t < 0.0f || t >= t_min)
			continue ;
		t_min = t;
		if (object != NULL)
			*object = &s->objects[i];
	}
	return (t_min);
}

static t_vec3	trace_scene(t_ray *r);

t_vec3	reflection(t_ray *r, t_vec3 p, t_vec3 n, t_object *o)
{
	if (r->bounce-- == 0)
		return (vec3(0, 0, 0));
	if (random_float(r->rng) > o->metallic)
	{
		r->rd = random_point_on_sphere(r->rng, 1.0f);
	}
	else
	{
		r->rd = reflect3(r->rd, n);
		r->rd = norm3(add3(r->rd, random_point_on_sphere(r->rng, o->rough)));
	}
	r->rd = scale3(r->rd, copysignf(1.0f, dot3(r->rd, n)));
	r->ro = p;
	return (trace_scene(r));
}

static t_vec3	trace_scene(t_ray *r)
{
	t_shading	s;
	t_object	*object;
	const float	t = scene_distance(r->scene, r->ro, r->rd, &object);
	t_ray		copy;

	if (object == NULL)
		return (r->scene->ambient);
	if (object->type == OBJECT_LIGHT || !r->fancy)
		return (object->color);
	s.point = add3(r->ro, scale3(r->rd, t));
	object_params(object, &s);
	s.point = add3(s.point, scale3(s.normal, 1e-4f));
	if (object->bump != TEXTURE_NONE)
		apply_bumpmap(&s, object->bump, s.texcoord);
	copy = *r;
	s.ambient = reflection(r, s.point, s.normal, object);
	*r = copy; // FIXME
	return (shade_point(&s, r, object));
}

t_vec3	get_viewport_ray(t_render *r, float x, float y, bool jitter)
{
	const float		u = (x + r->jitter.x * jitter) / r->image->width;
	const float		v = (y + r->jitter.y * jitter) / r->image->height;
	const t_vec3	v0 = lerp3(r->viewport[0], r->viewport[1], u);
	const t_vec3	v1 = lerp3(r->viewport[2], r->viewport[3], u);

	return (norm3(lerp3(v0, v1, v)));
}

// Trace the color of the pixel at (x, y) in the image.

t_vec3	trace_pixel(t_render *r, float x, float y)
{
	t_vec3	disk;
	t_ray	ray;

	ray.fancy = r->fancy;
	ray.scene = r->scene;
	ray.rng = r->frame_samples + (int)x + (int)y * r->image->width;
	disk = random_point_in_disk(ray.rng, r->scene->aperture_size);
	ray.ro = add3(r->scene->pos, scale3(r->camera_x, disk.x));
	ray.ro = add3(ray.ro, scale3(r->camera_y, disk.y));
	ray.rd = get_viewport_ray(r, x, y, true);
	ray.rd = add3(r->scene->pos, scale3(ray.rd, r->scene->focus_depth));
	ray.rd = norm3(sub3(ray.rd, ray.ro));
	ray.bounce = MAX_RAY_BOUNCES;
	return (trace_scene(&ray));
}
#include "minirt.h"

// Add two 3D vectors component-wise.

t_vec3	add3(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x + b.x, a.y + b.y, a.z + b.z));
}

// Subtract two 3D vectors component-wise.

t_vec3	sub3(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x - b.x, a.y - b.y, a.z - b.z));
}

// Multiply two 3D vectors component-wise.

t_vec3	mul3(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x * b.x, a.y * b.y, a.z * b.z));
}

// Divide two 3D vectors component-wise.

t_vec3	div3(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x / b.x, a.y / b.y, a.z / b.z));
}

// Scale a 3D vector by some value. (Multiply all of its components by some
// value.)

t_vec3	scale3(t_vec3 v, float s)
{
	return (vec3(v.x * s, v.y * s, v.z * s));
}
#include "minirt.h"

// Get the dot product (scalar product) of two 3D vectors. The resulting value
// is proportional to the product of the lengths of the two vectors, and to the
// cosine of the angle between them.

float	dot3(t_vec3 a, t_vec3 b)
{
	return (a.x * b.x + a.y * b.y + a.z * b.z);
}

// Get the length (magnitude) of a 3D vector.

float	len3(t_vec3 v)
{
	return (sqrtf(dot3(v, v)));
}

// Get a normalized copy of a 3D vector. The resulting vector has the same
// direction as the input, but a length (magnitude) of 1. Results are undefined
// for the null vector (0, 0, 0).

t_vec3	norm3(t_vec3 v)
{
	return (scale3(v, 1.0f / len3(v)));
}

// Get the cross product of two 3D vectors. The resulting vector is
// perpendicular to the two vectors, and its length is equal to the product of
// the lengths of the input vectors.

t_vec3	cross3(t_vec3 a, t_vec3 b)
{
	const float	x = a.y * b.z - b.y * a.z;
	const float	y = a.z * b.x - b.z * a.x;
	const float	z = a.x * b.y - b.x * a.y;

	return (vec3(x, y, z));
}

// Get the reflected ray direction for an incident ray `i` and a surface normal
// `n`.

t_vec3	reflect3(t_vec3 i, t_vec3 n)
{
	return (sub3(i, scale3(n, 2.0f * dot3(n, i))));
}
#include "minirt.h"

// Convenience function for making a 3D vector from xyz-coordinates.

t_vec3	vec3(float x, float y, float z)
{
	return ((t_vec3){{x, y, z}});
}

// Do a linear interpolation between two 3D vectors. Returns a if t = 0, b if
// t = 1, and a point on the line between a and b when 0 ≤ t ≤ 1.

t_vec3	lerp3(t_vec3 a, t_vec3 b, float t)
{
	a = scale3(a, 1.0f - t);
	b = scale3(b, 0.0f + t);
	return (add3(a, b));
}

// Apply basic Reinhard tone mapping to a color.

t_vec3	tonemap3(t_vec3 v)
{
	return (div3(v, add3(v, vec3(1.0f, 1.0f, 1.0f))));
}

// Convert a color vector to sRGB, applying an approximate gamma curve.

t_vec3	to_srgb3(t_vec3 color)
{
	const float		gamma = 1.0f / 2.2f;

	color.r = powf(color.r, gamma);
	color.g = powf(color.g, gamma);
	color.b = powf(color.b, gamma);
	return (color);
}

// Convert a color vector to a 32-bit MLX pixel value. Clamps all color channels
// to [0, 1] before converting to 8 bits per channel. sRGB conversion and
// dithering should be done before this step!

uint32_t	to_color3(t_vec3 color)
{
	const uint32_t	r = 255.5f * saturate(color.r);
	const uint32_t	g = 255.5f * saturate(color.g);
	const uint32_t	b = 255.5f * saturate(color.b);

	return ((r << 24) | (g << 16) | (b << 8) | 255);
}
#include "minirt.h"

double	ft_atof(t_parse *m, const char *str)
{
	double	result;
	double	divisor;
	int		sign;

	result = 0.0;
	divisor = 10.0;
	sign = 1;
	while (*str == ' ' || *str == '\t' || *str == '\n')
		str++;
	if (*str == '+' || *str == '-')
		sign = -1 * (*str++ == '-');
	while (*str >= '0' && *str <= '9')
		result = result * 10.0 + (*str++ - '0');
	if (*str == '\0')
		return (result * sign);
	if (*str == '.')
		str++;
	fatal_if(m, *str < '0' || *str > '9', "Bad number: %s\n", str);
	while (*str >= '0' && *str <= '9')
	{
		result += (*str++ - '0') / divisor;
		divisor *= 10.0;
	}
	fatal_if(m, *str != '\0', "Not a number: %s", str);
	return (result * sign);
}

/*
 * Checks if all components of a vector are within given boundaries
 * @param v The vector to check
 * @param lower Lower boundary (inclusive)
 * @param upper Upper boundary (inclusive)
 * @return true if all components are within boundaries, false otherwise
 */
bool	in_range3(t_vec3 v, float lower, float upper)
{
	float		epsilon;

	epsilon = 0.001f;
	return ((v.x >= lower - epsilon) && (v.x <= upper + epsilon)
		&& (v.y >= lower - epsilon) && (v.y <= upper + epsilon) && (v.z >= lower
			- epsilon) && (v.z <= upper + epsilon));
}

/*
** Splits a string by a comma, strictly for 3 components.
** Calls fatal_if on error.
*/
static char	**ft_split_vec(t_parse *m, const char *str)
{
	char		**result;
	const char	*p1 = ft_strchr(str, ',');
	const char	*p2;

	p2 = NULL;
	if (p1)
		p2 = ft_strchr(p1 + 1, ',');
	fatal_if(m, p1 == NULL || p2 == NULL || ft_strchr(p2 + 1, ','),
		"Vector format must be 'x,y,z' with exactly 2 commas\n");
	result = malloc(sizeof(char *) * 4);
	fatal_if(m, result == NULL, "Memory allocation failure\n");
	result[0] = ft_substr(str, 0, p1 - str);
	result[1] = ft_substr(str, p1 - str + 1, p2 - (p1 + 1));
	result[2] = ft_substr(p2 + 1, 0, ft_strlen(p2 + 1));
	result[3] = NULL;
	if (result[0] == NULL || result[1] == NULL || result[2] == NULL)
	{
		free_array(result);
		fatal_if(m, true, "Memory allocation failure in substr\n");
	}
	return (result);
}

/*
* Parses a string "x,y,z" into a vec3 and (optionally) validates component range.
 * Exits on failure using fatal_if (no return value).
 * @param m       Parsing context (for unified cleanup on error)
 * @param str     Input string in the form "x,y,z"
 * @param out     Destination vector
 * @param limits  Two-element array {min, max}; if limits[0] == limits[1],
	range check is skipped
 */
void	parse3(t_parse *m, const char *str, t_vec3 *out, float limits[2])
{
	char	**split;

	split = ft_split_vec(m, str);
	*out = vec3(ft_atof(m, split[0]), ft_atof(m, split[1]), ft_atof(m,
				split[2]));
	free_array(split);
	fatal_if(m, fabs(out->x) == HUGE_VAL || fabs(out->y) == HUGE_VAL
		|| fabs(out->z) == HUGE_VAL,
		"Vector component is too large\n");
	if (limits[0] != limits[1])
		fatal_if(m, !in_range3(*out, limits[0], limits[1]),
			"Vector values must be between %d and %d\n", (int)limits[0],
			(int)limits[1]);
}
