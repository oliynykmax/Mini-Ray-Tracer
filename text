#include "minirt.h"

int	array_len(char **array)
{
	int	i;

	if (!array)
		return (0);
	i = 0;
	while (array[i])
		i++;
	return (i);
}

void	free_array(char **array)
{
	int	i;

	i = 0;
	if (!array)
		return ;
	while (array[i] != NULL)
		free(array[i++]);
	free(array);
}
#include "minirt.h"
#include <stdarg.h>

bool	mrt_assert(bool condition, char *format, ...)
{
	const int	errno_value = errno;
	va_list		args;

	if (condition == true)
		return (true);
	ft_fprintf(2, "Error\n");
	if (format != NULL || errno_value != 0)
	{
		if (errno_value != 0)
		{
			ft_putstr_fd(strerror(errno_value), STDERR_FILENO);
			ft_putstr_fd(": ", STDERR_FILENO);
		}
		va_start(args, format);
		printf_fd(2, format, &args);
		va_end(args);
	}
	return (false);
}
#include "minirt.h"

// Handle mouse movement of the camera, pitching around the x-axis when the
// mouse is moved up or down, and yawing around the y-axis when it's moved
// sideways. Returns true if the camera moved.

static bool	camera_mouse_movement(t_render *r)
{
	const float		fov = radians(r->scene->fov);
	const float		sensitivity = MOUSE_SENSITIVITY * sinf(fov * 0.5f);
	static int32_t	prev[2];
	int32_t			curr[2];
	int32_t			delta[2];

	mlx_get_mouse_pos(r->mlx, &curr[0], &curr[1]);
	delta[0] = curr[0] - prev[0];
	delta[1] = curr[1] - prev[1];
	prev[0] = curr[0];
	prev[1] = curr[1];
	if (mlx_is_mouse_down(r->mlx, MLX_MOUSE_BUTTON_LEFT)
		&& (delta[0] != 0 || delta[1] != 0))
	{
		r->camera_yaw -= sensitivity * delta[0];
		r->camera_pitch -= sensitivity * delta[1];
		r->camera_pitch = clamp(r->camera_pitch, radians(1), radians(179));
		r->scene->dir.x = sin(r->camera_pitch) * cos(r->camera_yaw);
		r->scene->dir.y = cos(r->camera_pitch);
		r->scene->dir.z = sin(r->camera_pitch) * sin(r->camera_yaw);
		return (true);
	}
	return (false);
}

// Handle keyboard movement of the camera, moving horizontally with the WASD
// keys, and vertically with the shift/space keys. Returns true if the camera
// moved.

static bool	camera_keyboard_movement(t_render *r)
{
	t_vec3	vec;
	t_vec3	move_x;
	t_vec3	move_z;
	t_keys	keys;

	move_x = vec3_normalize(vec3(r->camera_x.x, 0.0f, r->camera_x.z));
	move_z = vec3_normalize(vec3(r->camera_z.x, 0.0f, r->camera_z.z));
	keys.forward = mlx_is_key_down(r->mlx, KEY_FORWARD);
	keys.left = mlx_is_key_down(r->mlx, KEY_LEFT);
	keys.back = mlx_is_key_down(r->mlx, KEY_BACK);
	keys.right = mlx_is_key_down(r->mlx, KEY_RIGHT);
	keys.up = mlx_is_key_down(r->mlx, KEY_UP);
	keys.down = mlx_is_key_down(r->mlx, KEY_DOWN);
	vec = vec3(0.0f, keys.down - keys.up, 0.0f);
	vec = vec3_add(vec, vec3_scale(move_x, keys.right - keys.left));
	vec = vec3_add(vec, vec3_scale(move_z, keys.forward - keys.back));
	vec = vec3_scale(vec, 3.0f * r->mlx->delta_time);
	r->scene->pos = vec3_add(r->scene->pos, vec);
	return (vec3_length(vec) > 0.0f);
}

// Update the basis vectors for the camera coordinate system, and and find the
// direction vectors pointing toward the four corners of the viewport.

static void	camera_update_viewport(t_render *r)
{
	const float	view_h = 0.5f * tan(radians(r->scene->fov) * 0.5f);
	const float	view_w = view_h * (float) r->image->width / r->image->height;
	t_vec3		vec[4];

	r->camera_z = r->scene->dir;
	r->camera_x = vec3_cross(r->camera_z, vec3(0.0f, -1.0f, 0.0f));
	r->camera_x = vec3_normalize(r->camera_x);
	r->camera_y = vec3_cross(r->camera_z, r->camera_x);
	vec[0] = vec3_scale(r->camera_x, -view_w);
	vec[1] = vec3_scale(r->camera_x, +view_w);
	vec[2] = vec3_scale(r->camera_y, -view_h);
	vec[3] = vec3_scale(r->camera_y, +view_h);
	r->viewport[0] = vec3_add(vec3_add(vec[0], vec[2]), r->camera_z);
	r->viewport[1] = vec3_add(vec3_add(vec[1], vec[2]), r->camera_z);
	r->viewport[2] = vec3_add(vec3_add(vec[0], vec[3]), r->camera_z);
	r->viewport[3] = vec3_add(vec3_add(vec[1], vec[3]), r->camera_z);
}

// Update all camera parameters. Called before rendering a new frame.

void	camera_update(t_render *r)
{
	if (camera_mouse_movement(r))
		r->frame_samples = 0;
	camera_update_viewport(r);
	if (camera_keyboard_movement(r))
		r->frame_samples = 0;
	r->jitter_x = fract(r->frame_samples * PLASTIC_RATIO_X);
	r->jitter_y = fract(r->frame_samples * PLASTIC_RATIO_Y);
	r->frame_samples++;
}
#include "minirt.h"

void	cleanup_scene(t_scene *sc)
{
	if (!sc)
		return ;
	if (sc->objects)
	{
		free(sc->objects);
		sc->objects = NULL;
	}
	sc->object_count = 0;
	sc->fov = 0;
	sc->pos = vec3(0, 0, 0);
	sc->dir = vec3(0, 0, 0);
	sc->ambient = vec3(0, 0, 0);
}
#include "minirt.h"

// Get the distance along a ray to a cylinder body.

static float	body_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	const float	a = (rd.x * rd.x + rd.z * rd.z);
	const float	b = (rd.x * ro.x + rd.z * ro.z) * 2.0f;
	const float	c = (ro.x * ro.x + ro.z * ro.z) - o->radius * o->radius;
	const float	t = solve_quadratic(a, b, c);

	if (fabsf(ro.y + t * rd.y) > o->height * 0.5f)
		return (1e9f);
	return (t);
}

// Get the distance along a ray to a cylinder end cap (a disk).

static float	disk_distance(t_object *o, t_vec3 ro, t_vec3 rd, float h)
{
	const float		t = (h - ro.y) / rd.y;
	const float		x = ro.x + t * rd.x;
	const float		z = ro.z + t * rd.z;

	if (t < 0.0f || x * x + z * z > o->radius * o->radius)
		return (1e9f);
	return (t);
}

// Get the distance along a ray to a full cylinder.

float	cylinder_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	const float	body = body_distance(o, ro, rd);
	const float	top = disk_distance(o, ro, rd, -0.5f * o->height);
	const float	bot = disk_distance(o, ro, rd, +0.5f * o->height);

	return (fminf(body, fminf(top, bot)));
}

// Get the normal of a cylinder at a point `p` on its surface.

t_vec3	cylinder_normal(t_object *o, t_vec3 p)
{
	if (fabsf(p.y) < o->height * 0.5f - 1e-6f)
		return (vec3_scale(vec3(p.x, 0.0f, p.z), 1.0f / o->radius));
	return (vec3(0.0f, 1.0f, 0.0f));
}

// Get the texture coordinates of a cylinder at a point `p` on its surface.

t_vec3	cylinder_texcoord(t_object *o, t_vec3 p)
{
	p.y = clamp(p.y, -o->height * 0.5f, o->height * 0.5f);
	p.x = atan2f(p.x, p.z) / M_PI * 0.5f + 0.5f;
	return (p);
}
#include "minirt.h"

int	objects_malloc_manager(t_scene *sc)
{
	static int	is_malloced = 0;
	static int	capacity = 64;
	t_object	*new_objects;

	if (!is_malloced)
	{
		sc->objects = malloc(capacity * sizeof(t_object));
		if (!sc->objects)
			return (1);
		is_malloced = 1;
	}
	else if (sc->object_count >= (size_t)capacity)
	{
		capacity *= 2;
		new_objects = malloc(capacity * sizeof(t_object));
		if (!new_objects)
			return (1);
		memcpy(new_objects, sc->objects, sc->object_count * sizeof(t_object));
		free(sc->objects);
		sc->objects = new_objects;
	}
	return (0);
}

int	process_line(t_scene *sc, char *buff)
{
	char	**line;
	bool	error;

	line = ft_split(buff, ' ');
	if (line == NULL || !line[0])
	{
		free_array(line);
		return (1);
	}
	if (ft_strcmp(line[0], "C") == 0)
		error = parse_camera(line, sc);
	else if (ft_strcmp(line[0], "L") == 0 || ft_strcmp(line[0], "A") == 0
		|| ft_strcmp(line[0], "sp") == 0 || ft_strcmp(line[0], "pl") == 0
		|| ft_strcmp(line[0], "cy") == 0 || ft_strcmp(line[0], "cn") == 0)
		error = parse_object(line, sc);
	else
		error = !mrt_assert(false, "Not a valid object type");
	free_array(line);
	return (error);
}

bool	read_map_into_scene(int fd, t_scene *sc)
{
	char	*buff;

	while (1)
	{
		buff = get_next_line(fd);
		if (!buff)
			break ;
		if (!ft_str_is_whitespace(buff))
		{
			if (process_line(sc, buff))
			{
				free(buff);
				cleanup_scene(sc);
				return (false);
			}
		}
		free(buff);
	}
	return (sc->object_count > 0);
}

static bool	ends_with_rt(const char *path)
{
	const char	*dot = ft_strrchr(path, '.');

	if (!dot)
		return (false);
	if (dot != NULL && *(dot + 1) != '\0')
		return (ft_strcmp(dot, ".rt") == 0);
	return (false);
}

bool	validate_input_and_parse_map(int ac, char **av, t_scene *scene)
{
	int	fd;

	if (!mrt_assert(ac == 2 && ends_with_rt(av[1]),
			"usage: ./miniRT <path_to_the_file.rt>\n"))
		return (false);
	fd = open(av[1], O_RDONLY);
	if (fd < 0)
	{
		ft_fprintf(2, "Error\nCould not open file %s\n", av[1]);
		return (false);
	}
	read_map_into_scene(fd, scene);
	get_next_line(-1);
	close(fd);
	return (scene->object_count > 0);
}
#include "minirt.h"

// MLX loop hook. Runs every frame to render the next image.

static void	loop_hook(void *param)
{
	t_render *const	r = (t_render*) param;
	t_object *const	object = &r->scene->objects[2];
	t_quat			rotate;

	pthread_mutex_lock(&r->mutex);
	if (mlx_is_key_down(r->mlx, MLX_KEY_J))
	{
		rotate = quat_from_axis_angle(vec3(0.0f, 1.0f, 0.0f), 0.03f);
		object->rot = quat_multiply(rotate, object->rot);
		r->frame_samples = 0;
	}
	camera_update(r);
	show_stats_in_window_title(r);
	r->jobs_available += THREAD_COUNT;
	pthread_cond_broadcast(&r->available_cond);
	while (r->jobs_finished < r->jobs_available)
		pthread_cond_wait(&r->finished_cond, &r->mutex);
	pthread_mutex_unlock(&r->mutex);
}

// MLX key hook. Used to quit when the escape key is pressed.

static void	key_hook(mlx_key_data_t data, void *param)
{
	t_render *const	r = (t_render*) param;

	if (data.action == MLX_PRESS && data.key == MLX_KEY_ESCAPE)
		mlx_close_window(r->mlx);
}

// MLX window resize hook. Resizes the image to match the new window dimensions.

static void	resize_hook(int32_t width, int32_t height, void *param)
{
	t_render *const	r = (t_render*) param;
	const size_t	min_size = width * height * sizeof(t_vec3);

	mlx_resize_image(r->image, width, height);
	if (min_size > r->frame_size)
	{
		r->frame_size = min_size;
		free(r->frame);
		r->frame = malloc(r->frame_size);
		if (r->frame == NULL)
			mlx_close_window(r->mlx);
	}
	r->frame_samples = 0;
}

// Renderer entry point. Sets up the MLX state and installs all event hooks.

void	render_scene(t_render *r, t_scene *scene)
{
	r->scene = scene;
	r->camera_yaw = atan2(scene->dir.z, scene->dir.x);
	r->camera_pitch = acos(scene->dir.y);
	r->mlx = mlx_init(480, 360, "miniRT", true);
	if (r->mlx != NULL)
	{
		r->image = mlx_new_image(r->mlx, r->mlx->width, r->mlx->height);
		if (r->image && mlx_image_to_window(r->mlx, r->image, 0, 0) != -1)
		{
			r->frame_size = r->mlx->width * r->mlx->height * sizeof(t_vec3);
			r->frame = malloc(r->frame_size);
			if (r->frame != NULL)
			{
				mlx_key_hook(r->mlx, key_hook, r);
				mlx_resize_hook(r->mlx, resize_hook, r);
				if (mlx_loop_hook(r->mlx, loop_hook, r) && threads_init(r))
					mlx_loop(r->mlx);
				threads_quit(r);
			}
			free(r->frame);
		}
		mlx_delete_image(r->mlx, r->image);
	}
	mlx_terminate(r->mlx);
}
#include "minirt.h"

int	main(int ac, char **av)
{
	t_scene		scene;
	t_render	render;

	ft_bzero(&scene, sizeof(t_scene));
	ft_bzero(&render, sizeof(render));
	if (!validate_input_and_parse_map(ac, av, &scene))
	{
		cleanup_scene(&scene);
		return (1);
	}
	render_scene(&render, &scene);
	cleanup_scene(&scene);
	free(scene.objects);
	return (0);
}
#include "minirt.h"

// Clamp a value to the range [lower, upper].

float	clamp(float value, float lower, float upper)
{
	return (fmax(lower, fmin(upper, value)));
}

// Clamp a value to the range [0, 1].

float	saturate(float value)
{
	return (clamp(value, 0.0f, 1.0f));
}

// Convert an angle from degrees to radians.

float	radians(float degrees)
{
	return (degrees * (M_PI / 180.0f));
}

// Get the fractional part of a floating point number. (Discard the digits
// before the decimal point.)

float	fract(float x)
{
	return (x - floorf(x));
}

// Solve the quadratic equation ax² + bx + c. Returns the lower of the two
// roots, or if the lower root is negative, returns the higher root. If no
// solution exists, returns a huge float value.

float	solve_quadratic(float a, float b, float c)
{
	const float	d = b * b - 4.0f * a * c;

	if (d < 0.0f)
		return (1e9f);
	return ((copysignf(sqrtf(d), b + sqrtf(d)) - b) / (2.0f * a));
}
#ifndef MINIRT_H
# define MINIRT_H

# include <errno.h>
# include <fcntl.h>
# include <math.h>
# include <pthread.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>

# include "../assets/MLX42/include/MLX42/MLX42.h"
# include "../assets/libft/libft.h"

// The number of rendering threads to use.
# define THREAD_COUNT 12

// Mouse sensitivity (higher values = more sensitive).
# define MOUSE_SENSITIVITY 0.006

// Key bindings.
# define KEY_FORWARD	MLX_KEY_W			// Walk forward
# define KEY_LEFT		MLX_KEY_A			// Strafe left
# define KEY_BACK		MLX_KEY_S			// Walk backward
# define KEY_RIGHT		MLX_KEY_D			// Strafe right
# define KEY_UP			MLX_KEY_SPACE		// Float up
# define KEY_DOWN		MLX_KEY_LEFT_SHIFT	// Sink down

// Camera parameters for depth of field.
# define CAMERA_FOCUS 5.0 // Depth of focus (TODO: Add to parser)
# define CAMERA_APERTURE 0 // Camera aperture size (TODO: Add to parser)

// Constants used for generating random points. The number 1.324… is the
// "plastic ratio," which is the solution to the equation x³ = x + 1. This
// number has unique properties that are useful for generating points that look
// "random" but don't clump together like truly randomly generated points do.
# define PLASTIC_RATIO_X 0.7548776662466927 // (plastic ratio)¯¹
# define PLASTIC_RATIO_Y 0.5698402909980532 // (plastic ratio)¯²

# define TAU 6.283185307179586 // 2π

// Typedefs for enum/structure/union types.
typedef enum e_object_type	t_object_type;
typedef struct s_keys		t_keys;
typedef struct s_object		t_object;
typedef struct s_ray		t_ray;
typedef struct s_render		t_render;
typedef struct s_scene		t_scene;
typedef struct s_thread		t_thread;
typedef union u_quat		t_quat;
typedef union u_vec3		t_vec3;

// Typedefs for function types.
typedef float				(*t_distance_function)(t_object*, t_vec3, t_vec3);
typedef t_vec3				(*t_normal_function)(t_object*, t_vec3);
typedef t_vec3				(*t_texcoord_function)(t_object*, t_vec3);

// 3D coordinate vector type (also used for colors).
union	u_vec3
{
	struct // XYZ coordinate vector
	{
		float	x;
		float	y;
		float	z;
	};
	struct // RGB color vector
	{
		float	r;
		float	g;
		float	b;
	};
};

// Quaternion type (used for rotating/orienting objects).
union	u_quat
{
	struct
	{
		float	x;		// Imaginary
		float	y;		// Imaginary
		float	z;		// Imaginary
		float	w;		// Real
	};
	t_vec3		xyz;	// Imaginary parts as vector
};

// Enumeration for different scene object types.
enum	e_object_type
{
	OBJECT_PLANE,
	OBJECT_SPHERE,
	OBJECT_CYLINDER,
	OBJECT_PARA,
	OBJECT_LIGHT,
};

// Data describing one geometric object or light in the scene.
struct s_object
{
	t_object_type	type;	// Object type (one of OBJECT_xxx)
	t_vec3			pos;	// Object position in world coordinates
	t_quat			rot;	// Object rotation relative to world coordinates
	t_vec3			color;	// Surface color
	float			radius;	// Radius (sphere/cylinder/para)
	float			height;	// Height (cylinder/para)
};

struct s_ray
{
	uint16_t	rng;	// Index used for random number generation
	t_vec3		ro;		// Ray origin
	t_vec3		rd;		// Ray direction
	int			limit;	// Remaining ray bounces
};

// Data describing the objects in the scene.
struct s_scene
{
	t_object	*objects;		// Array of objects in the scene
	size_t		object_count;	// Length of the objects array
	t_vec3		pos;			// Camera position
	t_vec3		dir;			// Camera direction (normalized)
	float		fov;			// Camera field of view (in degrees)
	t_vec3		ambient;		// Ambient color (multiplied by ratio)
};

// Data for the current keyboard state.
struct s_keys
{
	int	forward;	// State of the key for walking forward
	int	back;		// State of the key for walking backward
	int	left;		// State of the key for strafing left
	int	right;		// State of the key for strafing right
	int	up;			// State of the key for floating up
	int	down;		// State of the key for sinking down
};

// Common renderer state.
struct s_render
{
	t_scene			*scene;					// The scene to render
	mlx_t			*mlx;					// MLX state
	mlx_image_t		*image;					// MLX image
	float			camera_yaw;				// Camera yaw angle (in radians)
	float			camera_pitch;			// Camera pitch angle (in radians)
	t_vec3			camera_x;				// Camera "right" vector
	t_vec3			camera_y;				// Camera "down" vector
	t_vec3			camera_z;				// Camera "forward" vector
	t_vec3			viewport[4];			// The four corners of the viewport
	t_vec3			*frame;					// Floating point frame buffer
	size_t			frame_size;				// Allocated size of the frame
	int				frame_samples;			// Number of accumulated samples
	float			jitter_x;				// Horizontal subpixel jitter
	float			jitter_y;				// Vertical subpixel jitter
	pthread_t		threads[THREAD_COUNT];	// Array of rendering threads
	int				threads_started;		// How many threads were initialized
	bool			threads_stop;			// Set to stop the render threads
	size_t			jobs_available;			// Available render jobs
	size_t			jobs_finished;			// Finished render jobs
	pthread_cond_t	available_cond;			// Tells when jobs become available
	pthread_cond_t	finished_cond;			// Tells when all jobs are finished
	pthread_mutex_t	mutex;					// Protects common render state
};

// Data for one render thread.
struct s_thread
{
	size_t	id;		// Index from 0 to THREAD_COUNT - 1
	size_t	job;	// Job index (always increasing)
	size_t	y_min;	// y-coordinate of top scanline of region
	size_t	y_max;	// y-coordinate of bottom scanline of region
};

// camera.c
void		camera_update(t_render *r);
// para.c
float		para_distance(t_object *o, t_vec3 ro, t_vec3 rd);
t_vec3		para_normal(t_object *o, t_vec3 p);
t_vec3		para_texcoord(t_object *o, t_vec3 p);
// cylinder.c
float		cylinder_distance(t_object *o, t_vec3 ro, t_vec3 rd);
t_vec3		cylinder_normal(t_object *o, t_vec3 p);
t_vec3		cylinder_texcoord(t_object *o, t_vec3 p);

// loop.c
void		render_scene(t_render *r, t_scene *scene);

// main.c
void		parse_scene(t_scene *scene, char *filename);

// math.c
float		clamp(float value, float lower, float upper);
float		saturate(float value);
float		radians(float degrees);
float		fract(float x);
float		solve_quadratic(float a, float b, float c);

// plane.c
float		plane_distance(t_object *o, t_vec3 ro, t_vec3 rd);
t_vec3		plane_normal(t_object *o, t_vec3 p);
t_vec3		plane_texcoord(t_object *o, t_vec3 p);

// quaternion.c
t_quat		quat_from_axis_angle(t_vec3 axis, float angle);
t_quat		quat_from_direction(t_vec3 direction);
t_quat		quat_multiply(t_quat a, t_quat b);
t_quat		quat_inverse(t_quat q);
t_vec3		quat_rotate_vec3(t_quat q, t_vec3 v);

// sphere.c
float		sphere_distance(t_object *s, t_vec3 ro, t_vec3 rd);
t_vec3		sphere_normal(t_object *s, t_vec3 p);
t_vec3		sphere_texcoord(t_object *s, t_vec3 d);

// threads.c
bool		threads_init(t_render *r);
void		threads_quit(t_render *r);

// title.c
void		show_stats_in_window_title(t_render *r);

// trace.c
t_vec3		trace_pixel(t_render *r, float x, float y);

// vec3_arithmetic.c
t_vec3		vec3_add(t_vec3 a, t_vec3 b);
t_vec3		vec3_sub(t_vec3 a, t_vec3 b);
t_vec3		vec3_mul(t_vec3 a, t_vec3 b);
t_vec3		vec3_div(t_vec3 a, t_vec3 b);
t_vec3		vec3_scale(t_vec3 v, float s);

// vec3_geometric.c
float		vec3_dot(t_vec3 a, t_vec3 b);
float		vec3_length(t_vec3 v);
t_vec3		vec3_normalize(t_vec3 v);
t_vec3		vec3_cross(t_vec3 a, t_vec3 b);
t_vec3		vec3_reflect(t_vec3 i, t_vec3 n);

// vec3_utility.c
t_vec3		vec3(float x, float y, float z);
t_vec3		vec3_lerp(t_vec3 a, t_vec3 b, float t);
t_vec3		vec3_to_srgb(t_vec3 color);
uint32_t	vec3_to_color(t_vec3 color);

/* parsing of the map and validating the input input.c */
bool		validate_input_and_parse_map(int ac, char **av, t_scene *scene);
bool		parse_sphere(char **line, t_scene *sc);
bool		parse_plane(char **line, t_scene *sc);
bool		parse_para(char **line, t_scene *sc);
bool		parse_cylinder(char **line, t_scene *sc);
bool		parse_amb_light(char **line, t_scene *sc);
bool		parse_point_light(char **line, t_scene *sc);
bool		parse_object(char **line, t_scene *sc);
bool		parse_camera(char **line, t_scene *sc);
int			objects_malloc_manager(t_scene *sc);
/* asser	ting function, worth thinking if we want to builtin
 * the e	xiting and cleaning into it*/
bool		mrt_assert(bool condition, char *format, ...);
void		cleanup_scene(t_scene *sc);
/* array	 utils */
int			array_len(char **array);
void		free_array(char **array);
/* vector parsing utils */
double		ft_atof(const char *str);
bool		vec3_in_range(t_vec3 v, float lower, float upper);
bool		parse_vec3(char *str, t_vec3 *out, float min, float max);
bool		validate_input_and_parse_map(int ac, char **av, t_scene *scene);

#endif
#include "minirt.h"

// Body intersection: ray vs para shell

static float	body_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	float	k;
	float	a;
	float	b;
	float	t;
	float	y;

	k = (o->radius * o->radius) / o->height;
	ro.y += 0.5f * o->height;
	a = rd.x * rd.x + rd.z * rd.z;
	b = 2.0f * (ro.x * rd.x + ro.z * rd.z) - k * rd.y;
	t = solve_quadratic(a, b, ro.x * ro.x + ro.z * ro.z - k * ro.y);
	y = ro.y + t * rd.y;
	if (t < 0.0f || y < 0.0f || y > o->height)
		return (1e9f);
	return (t);
}

// Optional cap at top (y = +h/2), disk
static float	disk_distance(t_object *o, t_vec3 ro, t_vec3 rd, float h)
{
	const float	t = (h - ro.y) / rd.y;
	const float	x = ro.x + t * rd.x;
	const float	z = ro.z + t * rd.z;

	if (t < 0.0f || x * x + z * z > o->radius * o->radius)
		return (1e9f);
	return (t);
}

// Full intersection function
float	para_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	ro.y -= 0.5f * o->height;
	return (fminf(body_distance(o, ro, rd), disk_distance(o, ro, rd, +0.5f
				* o->height)));
}

t_vec3	para_normal(t_object *o, t_vec3 p)
{
	const float	k = (o->radius * o->radius) / o->height;

	if (fabsf(p.y - 0.5f * o->height) < 1e-4f)
		return (vec3(0, 1, 0));
	p.y += 0.5f * o->height;
	return (vec3_normalize(vec3(p.x, -k, p.z)));
}

// UV: cylindrical mapping
t_vec3	para_texcoord(t_object *o, t_vec3 p)
{
	p.y = clamp(p.y, 0, o->height);
	p.x = atan2f(p.x, p.z) / M_PI * 0.5f + 0.5f;
	return (p);
}
#include "minirt.h"

bool	parse_amb_light(char **line, t_scene *sc)
{
	static bool	ambient_exists = false;
	double		ratio;

	if (ambient_exists || array_len(line) != 3)
		return (true);
	ratio = ft_atof(line[1]);
	if (!parse_vec3(line[2], &sc->ambient, 0, 255) || !mrt_assert(ratio >= 0.0f
			&& ratio <= 1.0f,
			"Ambient light ratio must be between 0.0 and 1.0\n"))
		return (true);
	sc->ambient = vec3_scale(vec3_scale(sc->ambient, 1.0 / 255.0), ratio);
	ambient_exists = true;
	return (false);
}

bool	parse_point_light(char **line, t_scene *sc)
{
	t_object	*obj;
	double		brightness;

	if (array_len(line) != 4 || objects_malloc_manager(sc))
		return (true);
	brightness = ft_atof(line[2]);
	obj = &sc->objects[sc->object_count];
	obj->type = OBJECT_LIGHT;
	if (!parse_vec3(line[1], &obj->pos, 0, 0) || !parse_vec3(line[3],
			&obj->color, 0, 255) || !mrt_assert(brightness >= 0.0f
			&& brightness <= 1.0f,
			"Light brightness must be between 0.0 and 1.0\n"))
		return (true);
	obj->color = vec3_scale(vec3_scale(obj->color, 1.0 / 255.0), brightness);
	obj->rot = quat_from_axis_angle(vec3(0.0f, -1.0f, 0.0f), 0.0f);
	sc->object_count++;
	return (false);
}

// Then in read_map_into_scene, when errors occur:
/*
 * the command is going through array of strings that was passed to it
 * it will take the positions, split them, check if the length is 3,
	error if it is not
 * convert it to floats, check if it is within the limits
 * error if it is not
 * do the same with fov but without spliting
 *
 */
bool	parse_camera(char **line, t_scene *sc)
{
	static int	exist = 0;

	if (exist == 1 || array_len(line) != 4)
		return (true);
	sc->fov = ft_atof(line[3]);
	if (!parse_vec3(line[1], &sc->pos, 0, 0) || !parse_vec3(line[2],
			&sc->dir, -1, 1))
		return (true);
	exist = 1;
	return (!mrt_assert(fabsf(vec3_length(sc->dir) - 1.0f) < 0.001f,
			"Camera direction components must be between -1 and 1\n")
		|| !mrt_assert(sc->fov >= 0.0f && sc->fov <= 180.0f,
			"Camera FOV must be between 0 and 180 degrees\n"));
}
#include "minirt.h"

bool	parse_sphere(char **line, t_scene *sc)
{
	t_object	*obj;

	if (array_len(line) != 4 || objects_malloc_manager(sc))
		return (true);
	obj = &sc->objects[sc->object_count];
	obj->type = OBJECT_SPHERE;
	if (!parse_vec3(line[1], &obj->pos, 0, 0) || !parse_vec3(line[3],
			&obj->color, 0, 255))
		return (true);
	obj->radius = ft_atof(line[2]) / 2.0;
	if (!mrt_assert(obj->radius > 0.0f, "Sphere radius must be positive\n"))
		return (true);
	obj->color = vec3_scale(obj->color, 1.0 / 255.0);
	obj->rot = quat_from_axis_angle(vec3(0.0f, -1.0f, 0.0f), 0.0f);
	sc->object_count++;
	return (false);
}

bool	parse_plane(char **line, t_scene *sc)
{
	t_object	*obj;
	t_vec3		normal;

	if (array_len(line) != 4 || objects_malloc_manager(sc))
		return (true);
	obj = &sc->objects[sc->object_count];
	obj->type = OBJECT_PLANE;
	if (!parse_vec3(line[1], &obj->pos, 0, 0) || !parse_vec3(line[2],
			&normal, -1, 1) || !parse_vec3(line[3], &obj->color, 0, 255))
		return (true);
	if (!mrt_assert(fabsf(vec3_length(normal) - 1.0f) < 0.001f,
			"Plane normal must be a unit vector\n"))
		return (true);
	obj->color = vec3_scale(obj->color, 1.0 / 255.0);
	obj->rot = quat_from_direction(normal);
	sc->object_count++;
	return (false);
}

bool	parse_para(char **line, t_scene *sc)
{
	t_object	*obj;
	t_vec3		normal;

	if (array_len(line) != 6 || objects_malloc_manager(sc))
		return (true);
	obj = &sc->objects[sc->object_count];
	obj->type = OBJECT_PARA;
	if (!parse_vec3(line[1], &obj->pos, 0, 0) || !parse_vec3(line[2],
			&normal, -1, 1) || !parse_vec3(line[5], &obj->color, 0, 255))
		return (true);
	if (!mrt_assert(fabsf(vec3_length(normal) - 1.0f) < 0.001f,
			"para axis must be a unit vector\n"))
		return (true);
	obj->radius = ft_atof(line[3]) / 2.0;
	obj->height = ft_atof(line[4]);
	if (!mrt_assert(obj->radius > 0.0f, "para radius must be positive\n")
		|| !mrt_assert(obj->height > 0.0f, "para height must be positive\n"))
		return (true);
	obj->color = vec3_scale(obj->color, 1.0 / 255.0);
	obj->rot = quat_from_direction(normal);
	sc->object_count++;
	return (false);
}

bool	parse_cylinder(char **line, t_scene *sc)
{
	t_object	*obj;
	t_vec3		axis;

	if (array_len(line) != 6 || objects_malloc_manager(sc))
		return (true);
	obj = &sc->objects[sc->object_count];
	obj->type = OBJECT_CYLINDER;
	if (!parse_vec3(line[1], &obj->pos, 0, 0) || !parse_vec3(line[2],
			&axis, -1, 1) || !parse_vec3(line[5], &obj->color, 0, 255))
		return (true);
	if (!mrt_assert(fabsf(vec3_length(axis) - 1.0f) < 0.001f,
			"Cylinder axis must be a unit vector\n"))
		return (true);
	obj->radius = ft_atof(line[3]) / 2.0;
	obj->height = ft_atof(line[4]);
	if (!mrt_assert(obj->radius > 0.0f, "Cylinder diameter must be positive\n")
		|| !mrt_assert(obj->height > 0.0f,
			"Cylinder height must be positive\n"))
		return (true);
	obj->color = vec3_scale(obj->color, 1.0 / 255.0);
	obj->rot = quat_from_direction(axis);
	sc->object_count++;
	return (false);
}

bool	parse_object(char **line, t_scene *sc)
{
	if (ft_strcmp(line[0], "A") == 0)
		return (parse_amb_light(line, sc));
	else if (ft_strcmp(line[0], "L") == 0)
		return (parse_point_light(line, sc));
	else if (ft_strcmp(line[0], "sp") == 0)
		return (parse_sphere(line, sc));
	else if (ft_strcmp(line[0], "pl") == 0)
		return (parse_plane(line, sc));
	else if (ft_strcmp(line[0], "cy") == 0)
		return (parse_cylinder(line, sc));
	else if (ft_strcmp(line[0], "cn") == 0)
		return (parse_para(line, sc));
	return (true);
}
#include "minirt.h"

float	plane_distance(t_object *o, t_vec3 ro, t_vec3 rd)
{
	(void) o;
	return (-ro.y / rd.y);
}

t_vec3	plane_normal(t_object *o, t_vec3 p)
{
	(void) o, (void) p;
	return (vec3(0.0f, 1.0f, 0.0f));
}

t_vec3	plane_texcoord(t_object *o, t_vec3 p)
{
	(void) o;
	return (vec3(p.x, p.z, 0.0f));
}
#include "minirt.h"

// Create a quaternion from an axis and and an angle (in radians).

t_quat	quat_from_axis_angle(t_vec3 axis, float angle)
{
	const float	s = sinf(angle * 0.5f);
	const float	c = cosf(angle * 0.5f);

	return ((t_quat){{axis.x * s, axis.y * s, axis.z * s, c}});
}

// Create a quaternion from a direction vector.

t_quat	quat_from_direction(t_vec3 direction)
{
	const t_vec3	ref = vec3(0.0f, 1.0f, 0.0f);
	const t_vec3	axis = vec3_cross(direction, ref);
	const float		angle = acosf(vec3_dot(direction, ref));

	return (quat_from_axis_angle(axis, angle));
}

// Multiply two quaternions. This composes the rotations represented by the two
// quaternions.

t_quat	quat_multiply(t_quat a, t_quat b)
{
	const t_vec3	ab = vec3_scale(a.xyz, b.w);
	const t_vec3	ba = vec3_scale(b.xyz, a.w);
	const t_vec3	imag = vec3_add(vec3_cross(a.xyz, b.xyz), vec3_add(ab, ba));
	const float		real = a.w * b.w - vec3_dot(a.xyz, b.xyz);

	return ((t_quat){{imag.x, imag.y, imag.z, real}});
}

// Invert a quaternion. Conceptually, this reverses the rotation that the
// quaternion represents.

t_quat	quat_inverse(t_quat q)
{
	return ((t_quat){{-q.x, -q.y, -q.z, q.w}});
}

// Apply the rotation represented by the quaternion `q` to the 3D vector `v`.

t_vec3	quat_rotate_vec3(t_quat q, t_vec3 v)
{
	const t_vec3	a = vec3_add(vec3_cross(q.xyz, v), vec3_scale(v, q.w));

	return (vec3_add(v, vec3_scale(vec3_cross(q.xyz, a), 2.0f)));
}
#include "minirt.h"

float	sphere_distance(t_object *s, t_vec3 ro, t_vec3 rd)
{
	const float		a = vec3_dot(rd, rd);
	const float		b = vec3_dot(rd, ro) * 2.0f;
	const float		c = vec3_dot(ro, ro) - s->radius * s->radius;

	return (solve_quadratic(a, b, c));
}

t_vec3	sphere_normal(t_object *s, t_vec3 p)
{
	return (vec3_scale(p, 1.0f / s->radius));
}

t_vec3	sphere_texcoord(t_object *s, t_vec3 p)
{
	p.x = fmaxf(0.0f, atan2f(p.x, p.z) / M_PI * 0.5f + 0.5f);
	p.y = fmaxf(0.0f, asinf(p.y / s->radius) / M_PI + 0.5f);
	return (p);
}
#include "minirt.h"

// Dithering function for masking color banding artifacts. The specific method
// is called Interleaved Gradient Noise; there are some good articles on it on
// the web.

static t_vec3	dither(float x, float y)
{
	x *= 0.06711056f;
	y *= 0.00583715f;
	x = fract(52.9829189f * fract(x + y)) / 255.0f;
	return (vec3(x, x, x));
}

// Render one thread's region of the frame. The region extends from y_min to
// y_max. During this function, it's important that the thread only reads from
// common render and scene data, to avoid data races. The only memory the thread
// should write to is the color/pixel data of its own region of the frame.

static void	threads_render(t_render *r, uint32_t y_min, uint32_t y_max)
{
	uint32_t		x;
	uint32_t		y;
	t_vec3			color;
	size_t			index;
	const size_t	pitch = sizeof(t_vec3) * r->image->width * (y_max - y_min);

	if (r->frame_samples == 1)
		memset(r->frame + y_min * r->image->width, 0, pitch);
	y = y_min - 1;
	while (++y < y_max)
	{
		x = -1;
		while (++x < r->image->width)
		{
			index = x + y * r->image->width;
			color = trace_pixel(r, x, y);
			r->frame[index] = vec3_add(r->frame[index], color);
			color = vec3_scale(r->frame[index], 1.0f / r->frame_samples);
			color = vec3_to_srgb(color);
			color = vec3_add(color, dither(x, y));
			mlx_put_pixel(r->image, x, y, vec3_to_color(color));
		}
	}
}

// Render thread entry point. The frame is divided between threads into regions
// of equal size. When the MLX loop hook is called, the main thread increments
// the jobs_available counter to indicate that there is rendering work to be
// done. The render threads wait for work to become available, using a condition
// variable to avoid busy waiting. After rendering its region of the frame, each
// render thread increments the jobs_finished counter to indicate completion.
// When all jobs for one frame have finished, the main thread is signaled, after
// which it returns from the MLX loop hook, and the cycle repeats.

static void	*threads_main(void *arg)
{
	static _Atomic size_t	thread_id_counter;
	t_render *const			r = (t_render*) arg;
	t_thread				thread;

	thread.id = thread_id_counter++;
	thread.job = thread.id;
	while (true)
	{
		pthread_mutex_lock(&r->mutex);
		while (thread.job >= r->jobs_available && !r->threads_stop)
			pthread_cond_wait(&r->available_cond, &r->mutex);
		if (r->threads_stop)
			break ;
		pthread_mutex_unlock(&r->mutex);
		thread.y_min = r->image->height * (thread.id + 0) / THREAD_COUNT;
		thread.y_max = r->image->height * (thread.id + 1) / THREAD_COUNT;
		threads_render(r, thread.y_min, thread.y_max);
		pthread_mutex_lock(&r->mutex);
		if (++r->jobs_finished == r->jobs_available)
			pthread_cond_signal(&r->finished_cond);
		pthread_mutex_unlock(&r->mutex);
		thread.job += THREAD_COUNT;
	}
	pthread_mutex_unlock(&r->mutex);
	return (NULL);
}

// Create synchronization objects and start the render threads. Returns true on
// success, or false if an object couldn't be created. The threads_started
// counter keeps track of how many threads were actually started.

bool	threads_init(t_render *r)
{
	if (pthread_mutex_init(&r->mutex, NULL) != 0)
		return (false);
	if (pthread_cond_init(&r->available_cond, NULL) != 0
		|| pthread_cond_init(&r->finished_cond, NULL) != 0)
		return (false);
	while (r->threads_started < THREAD_COUNT)
	{
		if (pthread_create(&r->threads[r->threads_started], 0, threads_main, r))
			break ;
		r->threads_started++;
	}
	return (r->threads_started == THREAD_COUNT);
}

// Signal the render threads to stop, wait for all of them to finish, then
// destroy all synchronization objects.

void	threads_quit(t_render *r)
{
	pthread_mutex_lock(&r->mutex);
	r->threads_stop = true;
	pthread_cond_broadcast(&r->available_cond);
	pthread_mutex_unlock(&r->mutex);
	while (r->threads_started-- > 0)
		pthread_join(r->threads[r->threads_started], NULL);
	pthread_mutex_destroy(&r->mutex);
	pthread_cond_destroy(&r->available_cond);
	pthread_cond_destroy(&r->finished_cond);
}
#include "minirt.h"

// Add a string to the title buffer. Returns a pointer to the position in the
// buffer where the next character could be written.

static char	*add_string(char *buffer, char *string)
{
	while (*string != '\0')
		*buffer++ = *string++;
	return (buffer);
}

// Add an integer value to the title buffer. Returns a pointer to the position
// in the buffer where the next character could be written. Does not handle
// overflow if the value equals INT_MIN.

static char	*add_int(char *buffer, int value)
{
	if (value < 0)
	{
		*buffer++ = '-';
		return (add_int(buffer, -value));
	}
	if (value >= 10)
		buffer = add_int(buffer, value / 10);
	*buffer++ = '0' + value % 10;
	return (buffer);
}

// Build a string of useful stats and set it as the window title.

static void	update_window_title(t_render *r)
{
	char	title[256];
	char	*buffer;

	ft_bzero(title, sizeof(title));
	buffer = title;
	buffer = add_string(buffer, "miniRT — objects: ");
	buffer = add_int(buffer, r->scene->object_count);
	buffer = add_string(buffer, " | dt: ");
	buffer = add_int(buffer, r->mlx->delta_time * 1000.0);
	buffer = add_string(buffer, " ms");
	buffer = add_string(buffer, " | fps: ");
	buffer = add_int(buffer, 1.0 / r->mlx->delta_time);
	buffer = add_string(buffer, " | size: ");
	buffer = add_int(buffer, r->image->width);
	buffer = add_string(buffer, " x ");
	buffer = add_int(buffer, r->image->height);
	buffer = add_string(buffer, " | samples: ");
	buffer = add_int(buffer, r->frame_samples);
	mlx_set_window_title(r->mlx, title);
}

// Update the window title with useful stats, also rate-limiting title updates
// so that it's easier to read.

void	show_stats_in_window_title(t_render *r)
{
	static double	update_timer;
	const double	update_rate = 0.1;

	update_timer += r->mlx->delta_time;
	if (update_timer < update_rate)
		return ;
	update_timer = fmod(update_timer, update_rate);
	update_window_title(r);
}
#include "minirt.h"

static _Thread_local uint16_t	rng;

// Generate a random point in the unit square [0, 1]².

static t_vec3	random_point_in_square(void)
{
	const float	x = fract(PLASTIC_RATIO_X * rng);
	const float	y = fract(PLASTIC_RATIO_Y * rng);

	return (vec3(x, y, 0.0f));
}

// Generate a random point in a disk centered at the origin with the given
// radius.

static t_vec3	random_point_in_disk(float radius)
{
	const t_vec3	p = random_point_in_square();
	const float		x = sqrtf(p.x) * cosf(p.y * TAU) * radius;
	const float		y = sqrtf(p.x) * sinf(p.y * TAU) * radius;

	return (vec3(x, y, 0.0f));
}

// Generate a random point on a sphere centered at the origin with the given
// radius.

static t_vec3	random_point_on_sphere(float radius)
{
	const t_vec3	p = random_point_in_square();
	const float		x = sinf(p.x * M_PI) * cosf(p.y * TAU);
	const float		y = sinf(p.x * M_PI) * sinf(p.y * TAU);
	const float		z = cosf(p.x * M_PI);

	return (vec3_scale(vec3(x, y, z), radius));
}

static float	object_distance(t_object *object, t_vec3 ro, t_vec3 rd)
{
	static const t_distance_function	functions[] = {
		plane_distance,
		sphere_distance,
		cylinder_distance,
		para_distance,
	};

	ro = quat_rotate_vec3(quat_inverse(object->rot), vec3_sub(ro, object->pos));
	rd = quat_rotate_vec3(quat_inverse(object->rot), rd);
	return (functions[object->type](object, ro, rd));
}

static t_vec3	object_normal(t_object *obj, t_vec3 point)
{
	static const t_normal_function	functions[] = {
		plane_normal,
		sphere_normal,
		cylinder_normal,
		para_normal,
	};

	point = quat_rotate_vec3(quat_inverse(obj->rot), vec3_sub(point, obj->pos));
	return (quat_rotate_vec3(obj->rot, functions[obj->type](obj, point)));
}

static t_vec3	object_texcoord(t_object *obj, t_vec3 point)
{
	static const t_normal_function	functions[] = {
		plane_texcoord,
		sphere_texcoord,
		cylinder_texcoord,
		para_texcoord,
	};

	point = quat_rotate_vec3(quat_inverse(obj->rot), vec3_sub(point, obj->pos));
	return (functions[obj->type](obj, point));
}

static t_vec3	single_light(t_object *light, t_vec3 rd, t_vec3 n, t_vec3 p)
{
	const t_vec3	light_vec = vec3_sub(light->pos, p);
	const t_vec3	light_dir = vec3_normalize(light_vec);
	const t_vec3	half = vec3_normalize(vec3_sub(light_dir, rd));
	const float		diffuse = saturate(vec3_dot(light_dir, n));
	const float		specular = 5.0f * powf(fmaxf(0.0f, vec3_dot(n, half)), 30);
	t_vec3			color;

	color = vec3_scale(light->color, diffuse);
	color = vec3_add(color, vec3(specular, specular, specular));
	color = vec3_scale(color, 300.0f / vec3_dot(light_vec, light_vec));
	return (color);
}

static float	checkboard(float u, float v)
{
	u = floorf(u * 10.0f);
	v = floorf(v * 10.0f);
	return (0.1f + 0.9f * fract((u + v) * 0.5f));
}

float	scene_distance(t_scene *s, t_vec3 ro, t_vec3 rd, t_object **object)
{
	float		t_min;
	float		t;
	size_t		i;

	i = -1;
	if (object != NULL)
		*object = NULL;
	t_min = 1e9f;
	while (++i < s->object_count)
	{
		if (s->objects[i].type == OBJECT_LIGHT)
			continue ;
		t = object_distance(&s->objects[i], ro, rd);
		if (t < 0.0f || t >= t_min)
			continue ;
		t_min = t;
		if (object != NULL)
			*object = &s->objects[i];
	}
	return (t_min);
}

// Apply ambient/diffuse/specular lighting to a traced ray.

t_vec3	lighting(t_object *object, t_vec3 p, t_scene *s, t_vec3 rd)
{
	t_vec3	light;
	t_vec3	n;
	size_t	i;

	i = -1;
	light = s->ambient;
	n = object_normal(object, p);
	n = vec3_scale(n, copysignf(1.0f, -vec3_dot(rd, n)));
	p = vec3_add(p, vec3_scale(n, 1e-5f));
	while (++i < s->object_count)
	{
		if (s->objects[i].type == OBJECT_LIGHT)
		{
			t_vec3 rand = random_point_on_sphere(2.0f);
			t_vec3 light_pos = vec3_add(s->objects[i].pos, rand);
			t_vec3 light_dir = vec3_sub(light_pos, p);
			if (scene_distance(s, p, light_dir, NULL) >= 1.0f)
				light = vec3_add(light, single_light(&s->objects[i], rd, n, p));
		}
	}
	return (light);
}

static t_vec3	texturing(t_object *object, t_vec3 point)
{
	const t_vec3	texcoord = object_texcoord(object, point);
	const float		value = checkboard(texcoord.x, texcoord.y);

	return (vec3(value, value, value));
}

static t_vec3	trace_scene(t_scene *s, t_vec3 ro, t_vec3 rd, int limit)
{
	t_object	*object;
	t_vec3		point;
	t_vec3		color;
	const float	t = scene_distance(s, ro, rd, &object);

	if (object == NULL)
		return (s->ambient);
	point = vec3_add(ro, vec3_scale(rd, t));
	color = object->color;
	color = vec3_mul(color, texturing(object, point));
	color = vec3_mul(color, lighting(object, point, s, rd));
	if (object->type == OBJECT_CYLINDER)
	{
		t_vec3 n = object_normal(object, point);
		n = vec3_scale(n, copysignf(1.0f, -vec3_dot(rd, n)));
		t_vec3 p = vec3_add(point, vec3_scale(n, 1e-6f));
		n = vec3_reflect(rd, n);
		n = vec3_normalize(vec3_add(n, random_point_on_sphere(0.0f)));
		if (limit > 0)
			color = trace_scene(s, p, n, limit - 1);
		else
			color = vec3(0.0f, 0.0f, 0.0f);
	}
	return (color);
}

t_vec3	get_viewport_ray(t_render *r, float x, float y, bool jitter)
{
	const float		u = (x + r->jitter_x * jitter) / r->image->width;
	const float		v = (y + r->jitter_y * jitter) / r->image->height;
	const t_vec3	v0 = vec3_lerp(r->viewport[0], r->viewport[1], u);
	const t_vec3	v1 = vec3_lerp(r->viewport[2], r->viewport[3], u);

	return (vec3_normalize(vec3_lerp(v0, v1, v)));
}

// Trace the color of the pixel at (x, y) in the image.

t_vec3	trace_pixel(t_render *r, float x, float y)
{
	t_vec3	disk;
	t_vec3	ro;
	t_vec3	rd;

	rng = r->frame_samples + (int) x + (int) y * r->image->width;
	disk = random_point_in_disk(CAMERA_APERTURE);
	ro = vec3_add(r->scene->pos, vec3_scale(r->camera_x, disk.x));
	ro = vec3_add(ro, vec3_scale(r->camera_y, disk.y));
	rd = get_viewport_ray(r, x, y, true);
	rd = vec3_add(r->scene->pos, vec3_scale(rd, CAMERA_FOCUS));
	rd = vec3_normalize(vec3_sub(rd, ro));
	return (trace_scene(r->scene, ro, rd, 1));
}
#include "minirt.h"

// Add two 3D vectors component-wise.

t_vec3	vec3_add(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x + b.x, a.y + b.y, a.z + b.z));
}

// Subtract two 3D vectors component-wise.

t_vec3	vec3_sub(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x - b.x, a.y - b.y, a.z - b.z));
}

// Multiply two 3D vectors component-wise.

t_vec3	vec3_mul(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x * b.x, a.y * b.y, a.z * b.z));
}

// Divide two 3D vectors component-wise.

t_vec3	vec3_div(t_vec3 a, t_vec3 b)
{
	return (vec3(a.x / b.x, a.y / b.y, a.z / b.z));
}

// Scale a 3D vector by some value. (Multiply all of its components by some
// value.)

t_vec3	vec3_scale(t_vec3 v, float s)
{
	return (vec3(v.x * s, v.y * s, v.z * s));
}
#include "minirt.h"

// Get the dot product (scalar product) of two 3D vectors. The resulting value
// is proportional to the product of the lengths of the two vectors, and to the
// cosine of the angle between them.

float	vec3_dot(t_vec3 a, t_vec3 b)
{
	return (a.x * b.x + a.y * b.y + a.z * b.z);
}

// Get the length (magnitude) of a 3D vector.

float	vec3_length(t_vec3 v)
{
	return (sqrtf(vec3_dot(v, v)));
}

// Get a normalized copy of a 3D vector. The resulting vector has the same
// direction as the input, but a length (magnitude) of 1. Results are undefined
// for the null vector (0, 0, 0).

t_vec3	vec3_normalize(t_vec3 v)
{
	return (vec3_scale(v, 1.0f / vec3_length(v)));
}

// Get the cross product of two 3D vectors. The resulting vector is
// perpendicular to the two vectors, and its length is equal to the product of
// the lengths of the input vectors.

t_vec3	vec3_cross(t_vec3 a, t_vec3 b)
{
	const float	x = a.y * b.z - b.y * a.z;
	const float	y = a.z * b.x - b.z * a.x;
	const float	z = a.x * b.y - b.x * a.y;

	return (vec3(x, y, z));
}

// Get the reflected ray direction for an incident ray `i` and a surface normal
// `n`.

t_vec3	vec3_reflect(t_vec3 i, t_vec3 n)
{
	return (vec3_sub(i, vec3_scale(n, 2.0f * vec3_dot(n, i))));
}
#include "minirt.h"

// Convenience function for making a 3D vector from xyz-coordinates.

t_vec3	vec3(float x, float y, float z)
{
	return ((t_vec3){{x, y, z}});
}

// Do a linear interpolation between two 3D vectors. Returns a if t = 0, b if
// t = 1, and a point on the line between a and b when 0 ≤ t ≤ 1.

t_vec3	vec3_lerp(t_vec3 a, t_vec3 b, float t)
{
	a = vec3_scale(a, 1.0f - t);
	b = vec3_scale(b, 0.0f + t);
	return (vec3_add(a, b));
}

// Convert a color vector to sRGB, applying an approximate gamma curve.

t_vec3	vec3_to_srgb(t_vec3 color)
{
	const float		gamma = 1.0f / 2.2f;

	color.r = powf(color.r, gamma);
	color.g = powf(color.g, gamma);
	color.b = powf(color.b, gamma);
	return (color);
}

// Convert a color vector to a 32-bit MLX pixel value. Clamps all color channels
// to [0, 1] before converting to 8 bits per channel. sRGB conversion and
// dithering should be done before this step!

uint32_t	vec3_to_color(t_vec3 color)
{
	const uint32_t	r = 255.5f * saturate(color.r);
	const uint32_t	g = 255.5f * saturate(color.g);
	const uint32_t	b = 255.5f * saturate(color.b);

	return ((r << 24) | (g << 16) | (b << 8) | 255);
}
#include "minirt.h"

double	ft_atof(const char *str)
{
	double	result;
	double	divisor;
	int		sign;

	result = 0.0;
	divisor = 10.0;
	sign = 1;
	while (*str == ' ' || *str == '\t' || *str == '\n')
		str++;
	if (*str == '+' || *str == '-')
		if (*str++ == '-')
			sign = -1;
	while (*str >= '0' && *str <= '9')
		result = result * 10.0 + (*str++ - '0');
	if (*str == '.')
	{
		str++;
		while (*str >= '0' && *str <= '9')
		{
			result += (*str - '0') / divisor;
			divisor *= 10.0;
			str++;
		}
	}
	return (result * sign);
}

/*
 * Checks if all components of a vector are within given boundaries
 * @param v The vector to check
 * @param lower Lower boundary (inclusive)
 * @param upper Upper boundary (inclusive)
 * @return true if all components are within boundaries, false otherwise
 */
bool	vec3_in_range(t_vec3 v, float lower, float upper)
{
	float	epsilon;

	epsilon = 0.001f;
	return ((v.x >= lower - epsilon) && (v.x <= upper + epsilon)
		&& (v.y >= lower - epsilon) && (v.y <= upper + epsilon) && (v.z >= lower
			- epsilon) && (v.z <= upper + epsilon));
}

/*
 * Parses a string "x,y,z" into a vec3 and checks if values are within range
 * @param str The string to parse in format "x,y,z"
 * @param out Pointer to store the parsed vector
 * @param min Minimum allowed value (ignored if min == max)
 * @param max Maximum allowed value (ignored if min == max)
 * @return true on success, false on failure
 */
bool	parse_vec3(char *str, t_vec3 *out, float min, float max)
{
	char	**split;

	split = ft_split(str, ',');
	if (!mrt_assert(split != NULL, "Memory allocation failure\n"))
	{
		free_array(split);
		return (false);
	}
	if (!mrt_assert(array_len(split) == 3,
			"Vector format must be 'x,y,z' with 3 values\n"))
	{
		free_array(split);
		return (false);
	}
	*out = vec3(ft_atof(split[0]), ft_atof(split[1]), ft_atof(split[2]));
	free_array(split);
	if (min != max && !mrt_assert(vec3_in_range(*out, min, max),
			"Vector values must be between %d and %d\n", (int)min, (int)max))
		return (false);
	return (true);
}
